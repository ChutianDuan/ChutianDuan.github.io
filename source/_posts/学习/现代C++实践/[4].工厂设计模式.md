---
title: "工厂设计模式"
date: 2026-01-20 09:30:25
tags:
  - "C++"
  - "设计模式"
  - "工厂模式"
categories:
  - "学习"
  - "现代C++实践"
thumbnail: /img/covers/cover3.jpg
---
# 工厂设计模式
time：2026_1_20



## 虚函数
virtual
即使通过基类的指针或引用调用该函数，实际调用的函数是派生类中重写的版本
override
如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译
virtual 定义了父类中的子类需要重载的函数，override 则是确保子类在继承父类的时候必须进行重载，以防后续错误

``` c++
struct pet{
    virtual void speak() = 0;
};
struct cat::pet{
    void speak() override{
        print("miao");
    }
};
struct dog::pet{
    void speak() override{
        print("wano");
    }
};
void feed(Pet *pet) {
    puts("喂食");
    pet->speak();
    puts("喂食完毕");
}
int main(){
    pet *cat = new cat();
    pet *dog = new dog();
    freed(cat);
    freed(dog);
}
```
```c++
sturct Reduce(){
    virtual int init() = 0;
    virtual int add(int a,int b) = 0;
};

struct add_our :: Reduce(){
    int init() override{
        return 0;
    }
    int add(int a ,int b) override{
        return a+b;
    }
};
struct chen_our :: Reduce(){
    int init() override{
        return 1;
    }
    int add(int a,int b) override{
        return a*b;
    }
};

int reduce(std::vector<int> v,Reduce & reducer){
    int x =reducer->int();
    for(int i = 0;i<v.size();i++ ){
        x = reducer->add(x, v[i]);
    }
    return x
}

```

## 工厂模式

## 享元模式
享元模式：共享多个对象之间相同的部分，节省内存开销
共享同智能指标share_ptr实现多个对象指向同个资源在减少资源开销的同时，也通过rall特性完成智能内存管理
```c++
struct Sprite{
    vector<char> texture;
    void draw(glm::vec3 posoition){
        glDrawPixels(posoition, texture);
    }
};
struct Bullet{
    glm::vec3 posoition;
    glm::vec3 velocity;
    shared_ptr<Sprite> sprite;
    
    void draw(){
        sprite->draw(position, velocity);
    }
}
```
## 代理模式
