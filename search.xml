<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GAN生成式对抗网络</title>
    <url>/2024/09/13/GAN%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="GAN生成式对抗网络"><a href="#GAN生成式对抗网络" class="headerlink" title="GAN生成式对抗网络"></a>GAN生成式对抗网络</h1><p>GAN生成式对抗网络，GAN网络由生成网络和判别网络两个网络组成，生成式网络通过学习图片后将噪声转换为图片，而判别式网络将区分数据集图片和生成图片进行判别。生成式与判别式网络类似与小偷与警察，通过不断的博弈互相升级，在这场游戏中我们更加希望小偷取得胜利。既是生成式网络生成的图片可以让判别器难以判断。</p>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><h2 id="pytorch实现"><a href="#pytorch实现" class="headerlink" title="pytorch实现"></a>pytorch实现</h2><h2 id="GAN缺陷与改进"><a href="#GAN缺陷与改进" class="headerlink" title="GAN缺陷与改进"></a>GAN缺陷与改进</h2>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorh</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2026/01/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>pytorch 软件环境搭建</title>
    <url>/2024/08/29/pytorch-%E8%BD%AF%E4%BB%B6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Pytorch-环境搭建"><a href="#Pytorch-环境搭建" class="headerlink" title="Pytorch 环境搭建"></a>Pytorch 环境搭建</h1><h2 id="conda安装"><a href="#conda安装" class="headerlink" title="conda安装"></a>conda安装</h2><p>conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。我强烈推荐你使用他，他的作用类似于java中的maven和我们平时使用的虚拟机，他能够保证的项目之间互相是隔离的。举个简单的例子，如果你同时有两个项目，你一个使用的是pytorch1.8，一个用的是pytorch1.10，这样一个环境肯定就不够了，这个时候anaconda就派上大用场了，他可以创建两个环境，各用各的，互不影响，而且同过不同项目加载不同环境，也可以使项目加载更快更轻便。 </p>
<p>Anaconda有完整版和min版，完整版过于臃肿，因此推荐min版。下载地址推荐<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/">清华大学开源镜像网站</a>,如果不想自己挑选版本也可以点击这个链接下载楼主的版本<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py39_4.9.2-Windows-x86_64.exe">Miniconda3</a><br>不管下载那个版本的，请注意不要安装到C盘，这是因为conda的使用过程会占据大量内存，下载C盘会使得C盘内存紧张。<br>安装的时候，需要添加到系统路径这个选项也请务必选上，后面使用起来会带来很多便捷，并且这里的安装位置请你一定要记得，后面我们在Pycharm中将会使用到。  </p>
<p><img src="/pic/conda%E5%AE%89%E8%A3%85%E9%80%89%E6%8B%A9.png" alt="conda安装选择">  </p>
<h2 id="conda-虚拟环境创建"><a href="#conda-虚拟环境创建" class="headerlink" title="conda 虚拟环境创建"></a>conda 虚拟环境创建</h2><p>首先，我们要根据项目需求来创建一个环境，通过下面的指令创建并激活虚拟环境<br>本文这里以Python版本3.8.5为例子进行创建一个名为Pytorch的虚拟环境  </p>
<p><code>conda create -n Pytorch python==3.8.5</code><br><code>conda activate Pytorch</code>  </p>
<p><img src="/pic/%E8%BF%9B%E5%85%A5%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83.png" alt="conda安装选择">  </p>
<p>创建环境过程中需要下载，由于下载服务器不稳定，可能会出现下载错误。导致虚拟环境创建失败，创建成功后并进入虚拟环境，命令行出现Pytorch着表明环境创建成功。<br>一定要出现“Pytorch”没出现着表面没进入虚拟环境，会导致后续安装的包的都在基础环境中。  </p>
<h2 id="Pytorch-安装"><a href="#Pytorch-安装" class="headerlink" title="Pytorch 安装"></a>Pytorch 安装</h2><p>在安装Pytorch前需要缺确认电脑cuda驱动，cuda驱动不用自己安装，一般都随电脑自带的。可以在命令行中输入<code>nvidia-smi</code>  </p>
<p><img src="/pic/nvidia.png" alt="nvidia版本">  </p>
<p>正常出现这个输出着证明cuda驱动没问题，我们还需要记住 CUDA version 版本。上面的截图的版本是12.6.<br>后面pytorch安装需要更具你的cuda版本进行安装，cuda版本可以向下兼容，向上着会出现安装报错。<br>安装有两个选择，一个是去<a href="https://pytorch.org/get-started/locally/">官网</a>根据版本环境需求下载，但是由于服务器的原因下载并不稳定。本文后续介绍其它方法。</p>
<h3 id="Pytorch-CPU版本安装"><a href="#Pytorch-CPU版本安装" class="headerlink" title="Pytorch CPU版本安装"></a>Pytorch CPU版本安装</h3><p><code>conda install pytorch torchvision torchaudio cpuonly -c pytorch</code></p>
<h3 id="Pytroch-GPU版本安装"><a href="#Pytroch-GPU版本安装" class="headerlink" title="Pytroch GPU版本安装"></a>Pytroch GPU版本安装</h3><p><code>conda install pytorch==1.12.0 torchvision==0.13.0 torchaudio==0.12.0 cudatoolkit=11.3 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/win-64/</code></p>
<h2 id="Pycharm-IED-安装"><a href="#Pycharm-IED-安装" class="headerlink" title="Pycharm IED 安装"></a>Pycharm IED 安装</h2><p>Pycharm IED是python集成编辑器，目前<a href="https://www.jetbrains.com/pycharm/">Pycharm官网</a>有两个版本社区版和专业版。通常来说初学者使用<a href="https://download-cdn.jetbrains.com.cn/python/pycharm-community-2024.2.1.exe">Pycharm社区版</a>完全够用。另外如想使用专业版，由于专业版有使用期限，但学生可以利用学生邮箱（edu后缀）去省钱使用，可以免费白嫖！！！<br>安装Pycharm过程十分简单这里就过多赘述，仅建议安装过程在选择Pycharm需求时全选。</p>
<h3 id="conda-环境引入"><a href="#conda-环境引入" class="headerlink" title="conda 环境引入"></a>conda 环境引入</h3><p><img src="/pic/pytorchstep1.png" alt="step1"><br><img src="/pic/pytorchstep2.png" alt="step2">  </p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证在Pycharm中新建一个项目，新建项目安装前一掌将conda引入。<br>新建一个py文件并输入下面代码<br><code>import torch</code><br><code>print(torch.__version__)</code><br><code>print(torch.version.cuda)</code><br><code>print(torch.cuda. is_available())</code>  </p>
<p>进行运行，输出结果如下<br><img src="/pic/pytorch%E6%A3%80%E9%AA%8C.png" alt="检验结果"> </p>
<h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>第一片技术类文章完结撒花，总耗时4小时</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>一、预备知识</title>
    <url>/2024/09/05/%E4%B8%80%E3%80%81%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><h3 id="矩阵求导"><a href="#矩阵求导" class="headerlink" title="矩阵求导"></a>矩阵求导</h3><h3 id="反向传播（sum函数）"><a href="#反向传播（sum函数）" class="headerlink" title="反向传播（sum函数）"></a>反向传播（sum函数）</h3><p>&#96;&#96;<a href="https://blog.csdn.net/qq_43722079/article/details/136583592">https://blog.csdn.net/qq_43722079/article/details/136583592</a></p>
]]></content>
      <categories>
        <category>动手深度学习</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>torchvision路径应用失败问题</title>
    <url>/2024/09/05/torchvision%E8%B7%AF%E5%BE%84%E5%BA%94%E7%94%A8%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="torchvision模块路径引用问题"><a href="#torchvision模块路径引用问题" class="headerlink" title="torchvision模块路径引用问题"></a>torchvision模块路径引用问题</h1><p>前言：安装pytorch后可能会出现torch模块引用成功，而torchvision模块引用失败，失败原因为torchvision模块路径丢失。可能是三个问题导致的： </p>
<ol>
<li>torch和torchvision版本不匹配</li>
<li>pillow版本和torchvision版本不匹配</li>
</ol>
<h1 id="torch和torchvision版本不匹配"><a href="#torch和torchvision版本不匹配" class="headerlink" title="torch和torchvision版本不匹配"></a>torch和torchvision版本不匹配</h1><p>建议从pytorch官网重新下载新版pytorch，或者查询历史版本重新选择一个版本进行下载</p>
<h1 id="pillow版本和torchvision版本不匹配"><a href="#pillow版本和torchvision版本不匹配" class="headerlink" title="pillow版本和torchvision版本不匹配"></a>pillow版本和torchvision版本不匹配</h1><p>删除pillow 在重新下载pillow最新版</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始 第一篇博客</title>
    <url>/2024/08/24/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B-%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="博客的创建"><a href="#博客的创建" class="headerlink" title="博客的创建"></a>博客的创建</h1><p>当我写下这篇博客的时候，我很高兴我完成了我的第一篇博客的创作，虽然博客网站的运行等注意事项还没彻底掌握，但我很高兴至少自己完成了博客的初步制作。<br>以前在网络查询资料解决各种各式的问题，尝尝觉得这些大佬们技术叹为观止。不免在我脑海中产生一个问题，我能够成为像他们一样的人吗？  </p>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>个人博客的创建是为了记录我即将踏上的三年研究生生涯的点点滴滴，希望我能以梦为马，不负韶华。<br>先定下个小目标实现个人博客的月更和不断探索博客个性化希望等三年后的某一天回首这段时间，我能不留遗憾</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>研一第一月</title>
    <url>/2024/09/01/%E7%A0%94%E4%B8%80%E7%AC%AC%E4%B8%80%E6%9C%88/</url>
    <content><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>结束暑假，开始新学期</p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>暑假期间初步入门了深度学习和python，完成了小土堆深度学习入门和python，后续需要进一步加强</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><h2 id="学习-1"><a href="#学习-1" class="headerlink" title="学习"></a>学习</h2><p>继续学习深度学习和python，目前感觉深学习入门还是比较容易，希望学期结束能完成《动手深度学习》</p>
<h2 id="生活-1"><a href="#生活-1" class="headerlink" title="生活"></a>生活</h2><p>准备广东博物馆、广东图书馆游玩</p>
<h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><ol>
<li>博客一个星期更新一次，一个月更新一次技术类型文章</li>
<li>每月进行总结</li>
<li>精读《动手深度学习》并将每章进行笔记记录，计划本周完成前三章的精读</li>
<li>学习《流程使用python》</li>
</ol>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>第二次组会</title>
    <url>/2024/09/13/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%BB%84%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="第二次组会"><a href="#第二次组会" class="headerlink" title="第二次组会"></a>第二次组会</h1><p>一共四个人汇报，其中在投文献一篇方向为拉曼，三篇论汇报拉曼两片，层析一篇</p>
<h2 id="在投文献"><a href="#在投文献" class="headerlink" title="在投文献"></a>在投文献</h2><p>深度学习预测单细胞H2O2含量</p>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>细胞的数据集在预测问题上可以看作为时间序列，或者弱化其时间的数据看为序列。这种序列和文字序列有一定的相识性，在处理这方面数据可以更多的考虑循环神经网络和注意力机制进行处理</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>注意力机制</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>未知</p>
<h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><p>R^2</p>
<h2 id="论文问题"><a href="#论文问题" class="headerlink" title="论文问题"></a>论文问题</h2><p>网络结构不清晰，深度学习三要素 网络模型、损失函数和评价指标的选取有问题</p>
<h2 id="论文汇报"><a href="#论文汇报" class="headerlink" title="论文汇报"></a>论文汇报</h2><h3 id="transformer-RNN-超高清重建图像"><a href="#transformer-RNN-超高清重建图像" class="headerlink" title="transformer+RNN 超高清重建图像"></a>transformer+RNN 超高清重建图像</h3><h4 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h4><p>RNN(head)</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>组会</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake环境构建注意事项</title>
    <url>/2025/12/25/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/cmake%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="cmake环境构建注意事项"><a href="#cmake环境构建注意事项" class="headerlink" title="cmake环境构建注意事项"></a>cmake环境构建注意事项</h1><p>后续要装更多包：通用“镜像下载 + 安装模板”</p>
<p>你以后新增包基本分三类：CMake &#x2F; Autotools &#x2F; 纯 Make。建议统一规则：</p>
<p>下载：都落到 &#x2F;opt&#x2F;tp-downloads</p>
<p>解压构建：都在 &#x2F;opt&#x2F;src_clean&#x2F;<pkg></p>
<p>安装：统一 –prefix&#x3D;&#x2F;opt&#x2F;tp 或 -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;opt&#x2F;tp</p>
<p>使用：工程端统一 CMAKE_PREFIX_PATH&#x3D;&#x2F;opt&#x2F;tp</p>
<p>7.1 通用下载函数（带镜像）</p>
<p>建议你写个小函数（放到 ~&#x2F;.bashrc 或单独脚本）：</p>
<p>fetch_gh () {</p>
<h1 id="用法：fetch-gh-owner-repo-ref-output-tar-gz"><a href="#用法：fetch-gh-owner-repo-ref-output-tar-gz" class="headerlink" title="用法：fetch_gh owner repo ref output.tar.gz"></a>用法：fetch_gh owner repo ref output.tar.gz</h1><h1 id="例：fetch-gh-sewenew-redis-plus-plus-refs-tags-1-3-15-redis-plus-plus-1-3-15-tar-gz"><a href="#例：fetch-gh-sewenew-redis-plus-plus-refs-tags-1-3-15-redis-plus-plus-1-3-15-tar-gz" class="headerlink" title="例：fetch_gh sewenew redis-plus-plus refs&#x2F;tags&#x2F;1.3.15 redis-plus-plus-1.3.15.tar.gz"></a>例：fetch_gh sewenew redis-plus-plus refs&#x2F;tags&#x2F;1.3.15 redis-plus-plus-1.3.15.tar.gz</h1><p>  local owner&#x3D;”$1” repo&#x3D;”$2” ref&#x3D;”$3” out&#x3D;”$4”<br>  mkdir -p &#x2F;opt&#x2F;tp-downloads<br>  curl -L –fail <br>    “<a href="https://gh-proxy.org/https://github.com/$%7Bowner%7D/$%7Brepo%7D/archive/$%7Bref%7D.tar.gz">https://gh-proxy.org/https://github.com/${owner}/${repo}/archive/${ref}.tar.gz</a>“ <br>    -o “&#x2F;opt&#x2F;tp-downloads&#x2F;${out}”<br>}</p>
<p>7.2 CMake 类包安装模板<br>source &#x2F;opt&#x2F;tp&#x2F;env.sh<br>cd &#x2F;opt&#x2F;src_clean&#x2F;<pkg><br>rm -rf build &amp;&amp; mkdir build &amp;&amp; cd build<br>&#x2F;opt&#x2F;tp&#x2F;bin&#x2F;cmake .. -G Ninja <br>  -DCMAKE_BUILD_TYPE&#x3D;Release <br>  -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;opt&#x2F;tp <br>  -DCMAKE_PREFIX_PATH&#x3D;&#x2F;opt&#x2F;tp<br>&#x2F;opt&#x2F;tp&#x2F;bin&#x2F;cmake –build . -j”$(nproc)”<br>&#x2F;opt&#x2F;tp&#x2F;bin&#x2F;cmake –install .</p>
<p>7.3 Autotools 类包安装模板<br>.&#x2F;configure –prefix&#x3D;&#x2F;opt&#x2F;tp<br>make -j”$(nproc)”<br>make install</p>
<ol>
<li>下载 redis-plus-plus（走 GitHub 镜像）</li>
</ol>
<p>redis-plus-plus 最新 release&#x2F;tag 是 1.3.15。<br>GitHub</p>
<p>mkdir -p &#x2F;opt&#x2F;tp-downloads<br>cd &#x2F;opt&#x2F;tp-downloads</p>
<p>curl -L –fail <br>  “<a href="https://gh-proxy.org/https://github.com/sewenew/redis-plus-plus/archive/refs/tags/1.3.15.tar.gz">https://gh-proxy.org/https://github.com/sewenew/redis-plus-plus/archive/refs/tags/1.3.15.tar.gz</a>“ <br>  -o redis-plus-plus-1.3.15.tar.gz</p>
<ol start="2">
<li>解压、编译、安装到 &#x2F;opt&#x2F;tp</li>
</ol>
<p>关键 CMake 选项：</p>
<p>-DREDIS_PLUS_PLUS_BUILD_TEST&#x3D;OFF：不编测试，加速且避免额外依赖<br>GitHub<br>+1</p>
<p>-DCMAKE_PREFIX_PATH&#x3D;&#x2F;opt&#x2F;tp：让它找到你已装的 hiredis（以及未来其他依赖）</p>
<p>source &#x2F;opt&#x2F;tp&#x2F;env.sh</p>
<p>cd &#x2F;opt&#x2F;src_clean<br>rm -rf redis-plus-plus-1.3.15<br>tar -xf &#x2F;opt&#x2F;tp-downloads&#x2F;redis-plus-plus-1.3.15.tar.gz<br>cd redis-plus-plus-1.3.15</p>
<p>rm -rf build<br>mkdir -p build<br>cd build</p>
<p>&#x2F;opt&#x2F;tp&#x2F;bin&#x2F;cmake .. -G Ninja <br>  -DCMAKE_BUILD_TYPE&#x3D;Release <br>  -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;opt&#x2F;tp <br>  -DCMAKE_PREFIX_PATH&#x3D;&#x2F;opt&#x2F;tp <br>  -DREDIS_PLUS_PLUS_BUILD_TEST&#x3D;OFF</p>
<p>&#x2F;opt&#x2F;tp&#x2F;bin&#x2F;cmake –build . -j”$(nproc)”<br>&#x2F;opt&#x2F;tp&#x2F;bin&#x2F;cmake –install .</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>CMake</tag>
        <tag>构建系统</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>libevent</title>
    <url>/2026/01/07/%E5%AD%A6%E4%B9%A0/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%5B1%5Dlibevent/</url>
    <content><![CDATA[<h1 id="libevent-笔记"><a href="#libevent-笔记" class="headerlink" title="libevent 笔记"></a>libevent 笔记</h1><h2 id="TCP-evconnlistener"><a href="#TCP-evconnlistener" class="headerlink" title="TCP evconnlistener"></a>TCP evconnlistener</h2><p>evconnlistener机制替代了之前socket bind listen 监听套字的创立</p>
<h3 id="创建evconnlistener-接口"><a href="#创建evconnlistener-接口" class="headerlink" title="创建evconnlistener 接口"></a>创建evconnlistener 接口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">evconnlistener</span> *<span class="built_in">evconnlistener_new</span>(<span class="keyword">struct</span> event_base *base,</span><br><span class="line">    evconnlistener_cb cb, <span class="type">void</span> *ptr, <span class="type">unsigned</span> flags, <span class="type">int</span> backlog,</span><br><span class="line">    <span class="type">evutil_socket_t</span> fd);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">evconnlistener</span> *<span class="built_in">evconnlistener_new_bind</span>(<span class="keyword">struct</span> event_base *base,</span><br><span class="line">    evconnlistener_cb cb, <span class="type">void</span> *ptr, <span class="type">unsigned</span> flags, <span class="type">int</span> backlog,</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">int</span> socklen);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">evconnlistener_free</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span></span>;</span><br></pre></td></tr></table></figure>
<p>evconnlistener_new和evconnlistener_new_bind都用于分配和返回一个新的用于监听连接的对象。 每个用于监听的对象都使用event_base来维护一个建立的连接。当有新的TCP 连接发生时，回调函数就会调用.</p>
<p>base： event_base对象。参考event_base。<br>cb： 回调函数， 当有新的TCP连接发生时，会唤醒回调函数。<br>ptr： 传递给回调函数的参数。<br>flags： 一些标志， 后面会进一步介绍。<br>backlog： 监听队列允许容纳的最大连接数。<br>fd： 函数evconnlistener_new假设我们已经绑定了套接字到要监听的端口上，fd参数就是我们已经绑定的socket套接字。<br>sa： evconnlistener_new_bind帮助我们绑定监听地址。sa就是传入的监听地址。<br>socklen： sa的长度。</p>
<p>一般通常情况下flags设置LEV_OPT_CLOSE_ON_FREE，LEV_OPT_REUSEABLE</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evconnlistener_cb)</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">evutil_socket_t</span> sock, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> len, <span class="type">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="监听开启和关闭"><a href="#监听开启和关闭" class="headerlink" title="监听开启和关闭"></a>监听开启和关闭</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">evconnlistener_disable</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evconnlistener_enable</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="从enconnlistener-中获取信息"><a href="#从enconnlistener-中获取信息" class="headerlink" title="从enconnlistener 中获取信息"></a>从enconnlistener 中获取信息</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得一个evconnlistener对象的套接字</span></span><br><span class="line"><span class="function"><span class="type">evutil_socket_t</span> <span class="title">evconnlistener_get_fd</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span></span>;</span><br><span class="line"><span class="comment">// 获得一个evconnlistener对象event_base对象</span></span><br><span class="line"><span class="function"><span class="type">evutil_socket_t</span> <span class="title">evconnlistener_get_base</span><span class="params">(<span class="keyword">struct</span> evconnlistener *lev)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="完整示范"><a href="#完整示范" class="headerlink" title="完整示范"></a>完整示范</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">echo_read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/*获取读入读出缓冲区*/</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">evbuffer</span> *input = <span class="built_in">bufferevent_get_input</span>(bev);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">evbuffer</span> *output = <span class="built_in">bufferevent_get_output</span>(bev);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 将输入缓冲区的内容添加到输出缓冲区，实现回声功能 */</span></span><br><span class="line">        <span class="built_in">evbuffer_add_buffer</span>(output, input);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">echo_event_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> events, <span class="type">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR)</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;Error from bufferevent&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (events &amp; (BEV_EVENT_EOF | BEV_EVENT_ERROR)) &#123;</span><br><span class="line">                <span class="built_in">bufferevent_free</span>(bev);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">accept_conn_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">evutil_socket_t</span> fd, <span class="keyword">struct</span> sockaddr *address, <span class="type">int</span> socklen,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">event_base</span> *base = <span class="built_in">evconnlistener_get_base</span>(listener);<span class="comment">//获取事件</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">bufferevent</span> *bev = <span class="built_in">bufferevent_socket_new</span>(</span><br><span class="line">                base, fd, BEV_OPT_CLOSE_ON_FREE);<span class="comment">//建立连接</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">bufferevent_setcb</span>(bev, echo_read_cb, <span class="literal">NULL</span>, echo_event_cb, <span class="literal">NULL</span>);<span class="comment">//设置read和错误回调函数，传入参数为0</span></span><br><span class="line"> </span><br><span class="line">        <span class="built_in">bufferevent_enable</span>(bev, EV_READ|EV_WRITE);<span class="comment">//设置出发条件，EV_READ 读入时触发，EV_WRITE 错误是触发</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">accept_error_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener, <span class="type">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">event_base</span> *base = <span class="built_in">evconnlistener_get_base</span>(listener);</span><br><span class="line">        <span class="type">int</span> err = <span class="built_in">EVUTIL_SOCKET_ERROR</span>();</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Got an error %d (%s) on the listener. &quot;</span></span><br><span class="line">                <span class="string">&quot;Shutting down.\n&quot;</span>, err, <span class="built_in">evutil_socket_error_to_string</span>(err));</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">event_base_loopexit</span>(base, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">event_base</span> *base;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">evconnlistener</span> *listener;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sin;</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> port = <span class="number">9876</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                port = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (port&lt;=<span class="number">0</span> || port&gt;<span class="number">65535</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Invalid port&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        base = <span class="built_in">event_base_new</span>();</span><br><span class="line">        <span class="keyword">if</span> (!base) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Couldn&#x27;t open event base&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;sin, <span class="number">0</span>, <span class="built_in">sizeof</span>(sin));</span><br><span class="line"></span><br><span class="line">        sin.sin_family = AF_INET;</span><br><span class="line">        sin.sin_addr.s_addr = <span class="built_in">htonl</span>(<span class="number">0</span>);</span><br><span class="line">        sin.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"> </span><br><span class="line">        listener = <span class="built_in">evconnlistener_new_bind</span>(base, accept_conn_cb, <span class="literal">NULL</span>,</span><br><span class="line">            LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE, <span class="number">-1</span>,</span><br><span class="line">            (<span class="keyword">struct</span> sockaddr*)&amp;sin, <span class="built_in">sizeof</span>(sin));</span><br><span class="line">        <span class="keyword">if</span> (!listener) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;Couldn&#x27;t create listener&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">evconnlistener_set_error_cb</span>(listener, accept_error_cb);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">event_base_dispatch</span>(base);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bufferevents"><a href="#bufferevents" class="headerlink" title="bufferevents"></a>bufferevents</h2><p>bufferevent 由一个底层传输系统（比如socket），一个读缓冲区和一个写缓冲区组成</p>
<h3 id="bufferevent和evbuffers"><a href="#bufferevent和evbuffers" class="headerlink" title="bufferevent和evbuffers"></a>bufferevent和evbuffers</h3><p>每一个bufferevent 都有一个输入缓冲区和输出缓冲区， 这些缓冲区（buffer）都是struct evbuffer 类型</p>
<h3 id="基于socket-的bufferevent"><a href="#基于socket-的bufferevent" class="headerlink" title="基于socket 的bufferevent"></a>基于socket 的bufferevent</h3><p>bufferevent_socket_new()<br>struct bufferevent *bufferevent_socket_new(<br>    struct event_base *base,<br>    evutil_socket_t fd,<br>    enum bufferevent_options options);</p>
<p>正常通过ip host进行访问 后续可以使用socket进行构建client客户端连接简化实现<br>int bufferevent_socket_connect(struct bufferevent *bev,<br>    struct sockaddr *address, int addrlen);<br>通过域名进行解析访问<br> int bufferevent_socket_connect_hostname(struct bufferevent *bev,<br>    struct evdns_base *dns_base, int family, const char *hostname,<br>    int port);<br>int bufferevent_socket_get_dns_error(struct bufferevent *bev);</p>
<p>注：<br>bufferevent_socket_connect和evconnlistener_new_bind的区别<br>bufferevent_socket_connect：用于主动建立连接，即作为客户端去连接服务器。<br>evconnlistener_new_bind：用于被动接受连接，即作为服务器监听端口并接受客户端的连接。</p>
<h3 id="回调函数-水位线操作"><a href="#回调函数-水位线操作" class="headerlink" title="回调函数 &amp; 水位线操作"></a>回调函数 &amp; 水位线操作</h3><p>水位线设置<br>void bufferevent_setwatermark(struct bufferevent *bufev, short events,<br>    size_t lowmark, size_t highmark);<br>events参数传入决定设置不同的水危险<br>EV_WRITE、 EV_READ</p>
<p>读、写、报错回调函数调用<br>void bufferevent_setcb(struct bufferevent *bufev,<br>    bufferevent_data_cb readcb, bufferevent_data_cb writecb,<br>    bufferevent_event_cb eventcb, void *cbarg);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">size_t</span> total_drained;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_callback</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">info</span> *inf = ctx;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evbuffer</span> *input = <span class="built_in">bufferevent_get_input</span>(bev);</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">evbuffer_get_length</span>(input);</span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">        inf-&gt;total_drained += len;</span><br><span class="line">        <span class="built_in">evbuffer_drain</span>(input, len);<span class="comment">// 和evbuffer_remove()操作类似，但不执行copy工作仅删除长度len的缓冲</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Drained %lu bytes from %s\n&quot;</span>,</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span>) len, inf-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">event_callback</span><span class="params">(<span class="keyword">struct</span> bufferevent *bev, <span class="type">short</span> events, <span class="type">void</span> *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">info</span> *inf = ctx;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evbuffer</span> *input = <span class="built_in">bufferevent_get_input</span>(bev);</span><br><span class="line">    <span class="type">int</span> finished = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (events &amp; BEV_EVENT_EOF) &#123;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="built_in">evbuffer_get_length</span>(input);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got a close from %s.  We drained %lu bytes from it, &quot;</span></span><br><span class="line">            <span class="string">&quot;and have %lu left.\n&quot;</span>, inf-&gt;name,</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)inf-&gt;total_drained, (<span class="type">unsigned</span> <span class="type">long</span>)len);</span><br><span class="line">        finished = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got an error from %s: %s\n&quot;</span>,</span><br><span class="line">            inf-&gt;name, <span class="built_in">evutil_socket_error_to_string</span>(<span class="built_in">EVUTIL_SOCKET_ERROR</span>()));</span><br><span class="line">        finished = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ctx);</span><br><span class="line">        <span class="built_in">bufferevent_free</span>(bev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bufferevent</span> *<span class="built_in">setup_bufferevent</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bufferevent</span> *b1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">info</span> *info1;</span><br><span class="line"></span><br><span class="line">    info1 = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> info));</span><br><span class="line">    info1-&gt;name = <span class="string">&quot;buffer 1&quot;</span>;</span><br><span class="line">    info1-&gt;total_drained = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... Here we should set up the bufferevent and make sure it gets</span></span><br><span class="line"><span class="comment">       connected... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trigger the read callback only whenever there is at least 128 bytes</span></span><br><span class="line"><span class="comment">       of data in the buffer. */</span></span><br><span class="line">    <span class="built_in">bufferevent_setwatermark</span>(b1, EV_READ, <span class="number">128</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bufferevent_setcb</span>(b1, read_callback, <span class="literal">NULL</span>, event_callback, info1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bufferevent_enable</span>(b1, EV_READ); <span class="comment">/* Start reading. */</span></span><br><span class="line">    <span class="keyword">return</span> b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bufferevent中的数据操作"><a href="#bufferevent中的数据操作" class="headerlink" title="bufferevent中的数据操作"></a>bufferevent中的数据操作</h3><p>获取不同缓冲区的evbuffer描述符<br>struct evbuffer *bufferevent_get_input(struct bufferevent *bufev);<br>struct evbuffer *bufferevent_get_output(struct bufferevent *bufev);</p>
<p>写入读入操作<br>int  bufferevent_write(struct  bufferevent <em>bufev,  const  void</em>data,  size_t  size);<br>int  bufferevent_write_buffer(struct  bufferevent <em>bufev,  struct  evbuffer</em>buf);</p>
<p>size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);<br>int bufferevent_read_buffer(struct bufferevent *bufev,<br>    struct evbuffer *buf);</p>
<h3 id="程序自我通信"><a href="#程序自我通信" class="headerlink" title="程序自我通信"></a>程序自我通信</h3><p>int bufferevent_pair_new(struct event_base *base, int options,<br>    struct bufferevent *pair[2]);</p>
<p>pair[0]和pair[1] 设置为一对相互连接的bufferevent</p>
<h2 id="evbuffer缓冲IO的实用功能"><a href="#evbuffer缓冲IO的实用功能" class="headerlink" title="evbuffer缓冲IO的实用功能"></a>evbuffer缓冲IO的实用功能</h2><p>创建和释放<br>struct evbuffer *evbuffer_new(void);<br>void evbuffer_free(struct evbuffer *buf);</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Linux高性能服务器编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>libevent</tag>
        <tag>Reactor</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP</title>
    <url>/2026/01/08/%E5%AD%A6%E4%B9%A0/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/UDP/</url>
    <content><![CDATA[<h1 id="UDP-通信"><a href="#UDP-通信" class="headerlink" title="UDP 通信"></a>UDP 通信</h1><p>time:2025_1_8<br>UDP是面向传输的网络协议，高速但不可靠</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[Linux网络基础——Lesson7.「传输层协议 UDP 与 TCP」（三次握手四次挥手）]<a href="https://www.cnblogs.com/yangykaifa/p/19447080">https://www.cnblogs.com/yangykaifa/p/19447080</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Linux高性能服务器编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>UDP</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>libevent</title>
    <url>/2026/01/07/%E5%AD%A6%E4%B9%A0/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%5B2%5Dlibevent/</url>
    <content><![CDATA[<h1 id="bufferevent"><a href="#bufferevent" class="headerlink" title="bufferevent"></a>bufferevent</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><ul>
<li><strong>bufferevent</strong>：在套接字之上封装了<strong>输入&#x2F;输出缓冲</strong>与<strong>回调</strong>机制的 I&#x2F;O 对象，避免手写 <code>read/write</code> 和边沿触发细节。</li>
<li><strong>事件循环</strong>：<code>event_base</code> 驱动，所有 I&#x2F;O、超时、信号都在此 loop 内调度。</li>
</ul>
<hr>
<h2 id="2-关键-API"><a href="#2-关键-API" class="headerlink" title="2. 关键 API"></a>2. 关键 API</h2><h3 id="buferevent-socket-new"><a href="#buferevent-socket-new" class="headerlink" title="buferevent_socket_new()"></a>buferevent_socket_new()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> bufferevent* <span class="title function_">bufferevent_socket_new</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">    <span class="type">evutil_socket_t</span> fd,           <span class="comment">// 通常传 -1，让 libevent 自己创建 socket</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> options                   <span class="comment">// 常用：BEV_OPT_CLOSE_ON_FREE | BEV_OPT_DEFER_CALLBACKS</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li><code>fd = -1</code>：由 libevent 负责创建 socket，更简洁。</li>
<li><code>BEV_OPT_CLOSE_ON_FREE</code>：在 <code>bufferevent_free()</code> 时自动关闭 socket。</li>
<li><code>BEV_OPT_DEFER_CALLBACKS</code>：把回调延迟到事件循环安全点执行，减少重入问题。</li>
</ul>
<h3 id="buferevent-socket-connect"><a href="#buferevent-socket-connect" class="headerlink" title="buferevent_socket_connect()"></a>buferevent_socket_connect()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bufferevent_socket_connect</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> bufferevent *bev,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> addrlen</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li>非阻塞发起连接；成功返回 0，失败返回 -1（同时触发 event 回调中的 <code>BEV_EVENT_ERROR</code>）。</li>
<li>连接成功后会触发 event 回调中的 <code>BEV_EVENT_CONNECTED</code>。</li>
</ul>
<blockquote>
<p>如果要用主机名而非 IP，推荐 <code>bufferevent_socket_connect_hostname()</code>（需配合 <code>evdns_base</code> 进行异步解析）。</p>
</blockquote>
<hr>
<h2 id="3-最小可用示例（IPv4）"><a href="#3-最小可用示例（IPv4）" class="headerlink" title="3. 最小可用示例（IPv4）"></a>3. 最小可用示例（IPv4）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">void</span>* ctx)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = bufferevent_read(bev, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fwrite(buf, <span class="number">1</span>, n, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="keyword">struct</span> bufferevent* bev, <span class="type">short</span> what, <span class="type">void</span>* ctx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (what &amp; BEV_EVENT_CONNECTED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[OK] connected\n&quot;</span>);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;GET / HTTP/1.1\r\nHost: 127.0.0.1\r\n\r\n&quot;</span>;</span><br><span class="line">        bufferevent_write(bev, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (what &amp; BEV_EVENT_EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] server closed\n&quot;</span>);</span><br><span class="line">        bufferevent_free(bev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (what &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line">        <span class="type">int</span> err = EVUTIL_SOCKET_ERROR();</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[ERR] %s\n&quot;</span>, evutil_socket_error_to_string(err));</span><br><span class="line">        bufferevent_free(bev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (what &amp; BEV_EVENT_TIMEOUT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] timeout\n&quot;</span>);</span><br><span class="line">        bufferevent_free(bev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span> =</span> event_base_new();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建套字 socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span>* <span class="title">bev</span> =</span> bufferevent_socket_new(</span><br><span class="line">        base, <span class="number">-1</span>, BEV_OPT_CLOSE_ON_FREE | BEV_OPT_DEFER_CALLBACKS);</span><br><span class="line">    <span class="comment">// 将read_cb event_cb 回调函数先绑定防止漏听</span></span><br><span class="line">    bufferevent_setcb(bev, read_cb, <span class="literal">NULL</span>, event_cb, <span class="literal">NULL</span>);</span><br><span class="line">    bufferevent_enable(bev, EV_READ | EV_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：设置读/写超时（连接阶段通常走写超时）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">rto</span> =</span> &#123;<span class="number">10</span>, <span class="number">0</span>&#125;, wto = &#123;<span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    bufferevent_set_timeouts(bev, &amp;rto, &amp;wto);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_port   = htons(<span class="number">8080</span>);</span><br><span class="line">    evutil_inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;<span class="built_in">sin</span>.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferevent_socket_connect(bev, (<span class="keyword">struct</span> sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        bufferevent_free(bev);</span><br><span class="line">        event_base_free(base);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line"></span><br><span class="line">    event_base_free(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-使用要点与常见坑"><a href="#4-使用要点与常见坑" class="headerlink" title="4. 使用要点与常见坑"></a>4. 使用要点与常见坑</h2><ol>
<li><p><strong>回调必须先设再 connect</strong><br>先 <code>bufferevent_setcb()</code> + <code>bufferevent_enable()</code>，再调用 <code>bufferevent_socket_connect()</code>，避免早到事件丢失。</p>
</li>
<li><p><strong>超时设置</strong></p>
<ul>
<li><code>bufferevent_set_timeouts()</code> 同时设置读&#x2F;写超时。</li>
<li>连接阶段通常依赖<strong>写超时</strong>触发（因为 connect 过程中会等待可写）。</li>
</ul>
</li>
<li><p><strong>水位（可选）</strong></p>
<ul>
<li>读水位：<code>bufferevent_setwatermark(bev, EV_READ, low, high)</code><br>当输入缓冲超过 <code>high</code> 时会<strong>暂时禁用读事件</strong>，防止内存暴涨。</li>
<li>写水位：同理控制输出缓冲积压。</li>
</ul>
</li>
<li><p><strong>线程安全</strong></p>
<ul>
<li>libevent 可多线程，但一个 <code>event_base</code> 通常<strong>只在一个线程</strong>内跑；跨线程提交任务请用 <code>event_base_once()</code> 或管道&#x2F;通知机制。</li>
</ul>
</li>
<li><p><strong>DNS 支持（推荐）</strong></p>
<ul>
<li>异步解析：<code>evdns_base_new(base, 1)</code> + <code>bufferevent_socket_connect_hostname(bev, dns, AF_UNSPEC, &quot;example.com&quot;, 80)</code></li>
<li>避免阻塞式 <code>getaddrinfo()</code>。</li>
</ul>
</li>
<li><p><strong>清理顺序</strong></p>
<ul>
<li>一般在 <code>event_cb</code> 收到 <code>EOF/ERROR/TIMEOUT</code> 后 <code>bufferevent_free()</code>；loop 退出后 <code>event_base_free()</code>。</li>
</ul>
</li>
<li><p><strong>错误定位</strong></p>
<ul>
<li><code>BEV_EVENT_ERROR</code> 时使用 <code>EVUTIL_SOCKET_ERROR()</code> + <code>evutil_socket_error_to_string()</code> 打印 errno。</li>
<li>常见：<code>ECONNREFUSED</code>（服务未起）、<code>ETIMEDOUT</code>（网络&#x2F;防火墙&#x2F;超时）、<code>EHOSTUNREACH</code>。</li>
</ul>
</li>
<li><p><strong>选项建议</strong></p>
<ul>
<li><code>BEV_OPT_CLOSE_ON_FREE</code>：免漏句柄</li>
<li><code>BEV_OPT_DEFER_CALLBACKS</code>：减少重入与回调嵌套</li>
<li>如需<strong>逐线程</strong>回调可考虑 <code>BEV_OPT_THREADSAFE</code>（需要启用 <code>evthread_use_pthreads()</code> 等）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="5-主机名连接（带-DNS）的示例（简版）"><a href="#5-主机名连接（带-DNS）的示例（简版）" class="headerlink" title="5. 主机名连接（带 DNS）的示例（简版）"></a>5. 主机名连接（带 DNS）的示例（简版）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/dns.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdns_base</span>* <span class="title">dns</span> =</span> evdns_base_new(base, <span class="number">1</span>); <span class="comment">// 1=初始化内置解析器</span></span><br><span class="line"><span class="type">int</span> rc = bufferevent_socket_connect_hostname(</span><br><span class="line">    bev, dns, AF_UNSPEC, <span class="string">&quot;example.com&quot;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">/* handle error */</span> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-小结（流程速记）"><a href="#6-小结（流程速记）" class="headerlink" title="6. 小结（流程速记）"></a>6. 小结（流程速记）</h2><ol>
<li><code>event_base_new()</code></li>
<li><code>bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE | BEV_OPT_DEFER_CALLBACKS)</code></li>
<li><code>bufferevent_setcb()</code> → <code>bufferevent_enable(EV_READ|EV_WRITE)</code> → <code>bufferevent_set_timeouts()</code></li>
<li><code>bufferevent_socket_connect()</code>（或 <code>_connect_hostname()</code>）</li>
<li>在 <code>event_cb</code> 处理 <code>BEV_EVENT_CONNECTED / EOF / ERROR / TIMEOUT</code></li>
<li>退出时 <code>bufferevent_free()</code>、<code>event_base_free()</code></li>
</ol>
<hr>
<h2 id="7-进阶建议"><a href="#7-进阶建议" class="headerlink" title="7. 进阶建议"></a>7. 进阶建议</h2><ul>
<li><strong>TLS</strong>：用 <code>bufferevent_openssl_socket_new()</code> 包装 SSL 会话，接口与普通 <code>bev</code> 基本一致。</li>
<li><strong>背压控制</strong>：配合水位、分块写入，避免写缓冲过大。</li>
<li><strong>协议层</strong>：在 <code>read_cb</code> 内从 <code>evbuffer</code> 取数据，做<strong>半包&#x2F;粘包</strong>处理（如定长头 + 可变体）。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>Linux高性能服务器编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>libevent</tag>
        <tag>事件驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能服务器编程笔记一</title>
    <url>/2025/12/16/%E5%AD%A6%E4%B9%A0/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    <content><![CDATA[<h1 id="高性能服务器编程笔记一"><a href="#高性能服务器编程笔记一" class="headerlink" title="高性能服务器编程笔记一"></a>高性能服务器编程笔记一</h1>]]></content>
      <categories>
        <category>学习</category>
        <category>Linux高性能服务器编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>Linux</tag>
        <tag>高性能服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>server</title>
    <url>/2026/01/20/%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E6%97%B6%E7%AB%9E%E6%8A%80%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/server/</url>
    <content><![CDATA[<h1 id="服务器分析"><a href="#服务器分析" class="headerlink" title="服务器分析"></a>服务器分析</h1><p>time：2026_1_20</p>
<p>ClientConn<br>    历史缓存<br>    tick<br>        最后输入tick<br>        最后权威tick<br>    最后输入包<br>    玩家数量</p>
<p>ServerCtx<br>    基础信息<br>        对局设置<br>        帧同步设置<br>        世界设置<br>    sock 网络<br>    clients 存储客户端状态<br>函数<br>    AssignSlot 分配id 1，2<br>    GetPlayer 从ServerCtx-&gt;clients 取出ClientConn<br>    OnlineCount 在线玩家统计<br>    GetCmdForTick 从ClientConn中获取动作信息，正常接受，如果出现延迟但小于延迟设置，着延续上一次包，但是出现过大延迟直接采用默认信息</p>
<pre><code>OnUdp 收包加入缓存
MaybeStartMatch for pid 轮训发收start包，其中通过利用getplayer 吧serverctx中的clientconn取出，同时检测ctx中的状态已start则跳过

OnTick 
    整体事件监听
    推进世界 + 给两边发 State/Ack
</code></pre>
]]></content>
      <categories>
        <category>学习</category>
        <category>实时竞技游戏开发</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>服务器</tag>
        <tag>后端架构</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟</title>
    <url>/2026/01/19/%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E6%97%B6%E7%AB%9E%E6%8A%80%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1>]]></content>
      <categories>
        <category>学习</category>
        <category>实时竞技游戏开发</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>物理模拟</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>client</title>
    <url>/2026/01/21/%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E6%97%B6%E7%AB%9E%E6%8A%80%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/client/</url>
    <content><![CDATA[<h1 id="Client-实现分析"><a href="#Client-实现分析" class="headerlink" title="Client 实现分析"></a>Client 实现分析</h1><p>time：2026_1_21</p>
<h2 id="app-依赖包"><a href="#app-依赖包" class="headerlink" title="app 依赖包"></a>app 依赖包</h2><p>ClientRender<br>    可视化</p>
<p>GameConfig<br>    client 基础信息参数 后续可以扩展到server 公用一个确保准确</p>
<p>InputPredicition<br>    预测 x,y 的动作</p>
<h2 id="主体部分"><a href="#主体部分" class="headerlink" title="主体部分"></a>主体部分</h2><p>ClientCtx</p>
<pre><code>lab::net::UdpSocket sock; 发收
lab::net::UdpAddr server&#123;&#125;; server 接受

localHist 本地
remoteHist 预测
stateHist 权威
</code></pre>
<p>BuildCmdVec （localPid localCmd remoteCmds）<br>    通过pid识别是否是本段，保存一个vector<inputcmd>cmds size &#x3D; 2的状态，本段保存输入，对端保存预测<br>    return （输入， 预测）&#x2F;&#x2F; vector<inputcmd>cmds size 2</p>
<p>GetRemoteCmdForTick  ctx pid t</p>
<pre><code>return (预测)
</code></pre>
<p>ApplyAuthoritativeState ctx st</p>
<h2 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h2><p>主要就就两条思路 接受处理，发收处理维护不同的状态</p>
<p>OnUdp<br>Recv：只负责收包 -&gt; 更新 ack&#x2F;state -&gt; 更新对手预测&#x2F;触发回滚</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>实时竞技游戏开发</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>同步</tag>
        <tag>客户端</tag>
      </tags>
  </entry>
  <entry>
    <title>渲染</title>
    <url>/2026/01/19/%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E6%97%B6%E7%AB%9E%E6%8A%80%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h1 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h1>]]></content>
      <categories>
        <category>学习</category>
        <category>实时竞技游戏开发</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>网络</title>
    <url>/2026/01/21/%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E6%97%B6%E7%AB%9E%E6%8A%80%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="网络开发总结"><a href="#网络开发总结" class="headerlink" title="网络开发总结"></a>网络开发总结</h1><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="NetCodec"><a href="#NetCodec" class="headerlink" title="NetCodec"></a>NetCodec</h3><ol>
<li><p>Input<br> ID,count, client(本端)最新tick, clientAckServerTick（server确认最新tick） cmd包</p>
</li>
<li><p>Ack<br> 权威tick， 最后tick 以及hash验证</p>
</li>
<li><p>Statae<br> 权威状态包</p>
</li>
<li><p>Start<br> 游戏开始通知</p>
</li>
</ol>
<h3 id="NetStub"><a href="#NetStub" class="headerlink" title="NetStub"></a>NetStub</h3><pre><code>废弃 tick 模拟状态发送和打印监控，状态发送已改为键盘输入
</code></pre>
<h3 id="Packets"><a href="#Packets" class="headerlink" title="Packets"></a>Packets</h3><ol>
<li>PacketType 状态，input ack state start</li>
<li>InputPacket 包 冗余发松多个InputCmd 包以防丢包</li>
<li>start 包<br> 对局状态信息</li>
</ol>
<h3 id="UdpSocket"><a href="#UdpSocket" class="headerlink" title="UdpSocket"></a>UdpSocket</h3><p>udp 连接比tcp简单，持续监听端口</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>实时竞技游戏开发</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>网络</tag>
        <tag>延迟</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣打卡学习记录</title>
    <url>/2025/12/16/%E5%AD%A6%E4%B9%A0/%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0/%E5%8A%9B%E6%89%A3%E6%89%93%E5%8D%A1%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><ol start="70">
<li>爬楼梯</li>
<li>使用最小花费爬楼梯</li>
<li>爬楼梯 II<br>需要注意数组初始化问题</li>
<li>组合总和 Ⅳ<br>翻译成爬楼梯的问题<br>这个题可以在想想扩展一下</li>
<li>统计构造好字符串的方案数<br>在dp数组不确定初始化的情况下<br>采用dfs的方法通过规定边界实现初始化简化</li>
<li>统计打字方案数【1】<br>好好在思考一下</li>
</ol>
<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><ol start="198">
<li>打家劫舍<br>lambda 在递归中应用需要补一下</li>
<li>打家劫舍 II</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>代码练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>Rall与智能指针</title>
    <url>/2025/12/19/%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%80%A7%E8%83%BDC++%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/Rall%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="Rall与智能指针"><a href="#Rall与智能指针" class="headerlink" title="Rall与智能指针"></a>Rall与智能指针</h1><p>帮我把这个整理一下“# RALL &amp; 智能指针</p>
<p>在多进程编程中由于相互进程线程之间相互关系，首先最重要的就是互相访问对象时不会产生冲突。<br>RAII（Resource Acquisition Is Initialization，资源获取即初始化）是一种在 C++ 中常见的编程范式，主要用于管理资源（如动态内存、文件句柄、网络连接等）。其核心思想是将资源的生命周期绑定到对象的生命周期，通过对象的构造函数来获取资源，通过对象的析构函数来释放资源。这种方式避免了显式的资源管理，减少了资源泄漏的可能性。</p>
<p>RALL 通常应用于 内存管理（智能指针）；文件管理；互斥锁管理<br>智能指针：unique_ptr shared_ptr</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程都有自己独立的一块内存空间，一个进程可以有多个线程。一个进程只的线程能共享资源</p>
<h2 id="多线形编程"><a href="#多线形编程" class="headerlink" title="多线形编程"></a>多线形编程</h2><h3 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h3><p>基础线程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(args)</span><span class="comment">// 自定义函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(foo args)</span> <span class="comment">//创建了命名为t一个子线程</span></span></span><br><span class="line"><span class="function">    std::<span class="title">thread::join</span><span class="params">()</span> <span class="comment">//  等待子线程运行完才会释放</span></span></span><br><span class="line"><span class="function">    std::<span class="title">thread::detach</span><span class="params">()</span> <span class="comment">//不用等待就能直接释放（会产生风险）</span></span></span><br><span class="line"><span class="function">    t.joinable <span class="comment">// std::thread::joinable</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// lambda </span></span></span><br><span class="line"><span class="function">    std::thread <span class="title">t</span><span class="params">([](<span class="type">int</span> a, <span class="type">int</span> b )&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout&lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;,<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">// 1 &quot;&quot; b</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数传递 智能指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_unique</span><span class="params">(std::unique_per *p)</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_shared</span><span class="params">(std::shared_per *p)</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 采用智能指针的好处，就是能自动detach()</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr_1 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);<span class="comment">//注意独占所有权</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr_2 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t_unique</span><span class="params">(foo_unique, std::move(ptr_1))</span></span>;</span><br><span class="line">    t_unique.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thrad <span class="title">t_shared</span><span class="params">(foo_shared, ptr_2)</span></span>;</span><br><span class="line">    t_shared.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>线程所有权管理 使用std::move()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo_2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_1</span><span class="params">(foo_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t_2</span><span class="params">(std::move(t_1))</span></span>;</span><br><span class="line">    t_1 = std::<span class="built_in">thread</span>(foo_2);</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt; t_<span class="number">1.</span><span class="built_in">joinable</span>();</span><br><span class="line">    std::cout&lt;&lt; t_<span class="number">2.</span><span class="built_in">joinable</span>();</span><br><span class="line"></span><br><span class="line">    std::thread t_3;</span><br><span class="line">    t3 = std::<span class="built_in">move</span>(t_2);</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// t2.join(); t2 已经通过std::move 将进程转移给了t3，t2里面为null t2.jion没有意义</span></span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::thrad scoped_thread RALL 自动join()&amp;detach()[需要在思考一下]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">scoped_thread</span>&#123;</span><br><span class="line">    std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread t_)</span>:t(std::move(t_))&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(!t.<span class="built_in">joinable</span>())&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;thread is unjoinable.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">scoped_thread</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">joinable</span>())&#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scoped_thread</span>(scoped_thread <span class="type">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    scoped_thread&amp; <span class="keyword">operator</span>=(scoped_thread <span class="type">const</span>&amp;) = dalete;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">scoped_thread <span class="title">st</span><span class="params">(std::thread(foo, <span class="number">100</span>))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPU核心 &amp; 支持线程数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    std::count&lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n = std::thread::<span class="built_in">hardware_concurrency</span>()<span class="comment">//获取核心数</span></span><br><span class="line">    </span><br><span class="line">    std::vector&lt;std::thread&gt; <span class="built_in">pv</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t :pv) t = std::<span class="built_in">thread</span>(foo);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : pv)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">joinable</span>()) t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥操作"><a href="#互斥操作" class="headerlink" title="互斥操作"></a>互斥操作</h3><p>互斥锁基于一种互斥的原则，即 同一时刻 只允许 一个线程访问被保护的资源。当一个线程获取互斥锁，其他试图访问共享资源的线程会被 阻塞，直到当前这个获取锁的线程 释放锁。确保避免了数据竞争的问题。<br>std::mutex</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过一个对列实现读入和读出，保证互相不冲突</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; msg_que;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in_msg_que</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> i&lt;num;i++)&#123;</span><br><span class="line">            mtx.<span class="built_in">lock</span>();</span><br><span class="line">            msg_que.<span class="built_in">push</span>(i);</span><br><span class="line">            mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">out_msg_que</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="type">int</span> commad;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pop_command</span>(command))&#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="built_in">pop_command</span>(<span class="type">int</span> &amp;commad)&#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(msg_que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            mtx.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        command = msg_que.<span class="built_in">front</span>();</span><br><span class="line">        msg_que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyCLass obj_a;</span><br><span class="line">    <span class="function">std::thread <span class="title">out_msg_t</span> <span class="params">(&amp;Myclass::out_msg_que, &amp;obj_a,<span class="number">7</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">in_msg_t</span><span class="params">(&amp;Myclass::in_msg_que, &amp;obj_a,<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="type">out_msg_t</span>.<span class="built_in">join</span>();</span><br><span class="line">    <span class="type">in_msg_t</span>.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::lock_guard 作用逾</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;<span class="comment">// &#123;&#125;中自动加锁</span></span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unique_lock lock_guard 升级版支持更多操作，但是带来更多的开销，简单的操作还是采用lock_guard</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">	std::queue&lt;<span class="type">int</span>&gt; msg_que; <span class="comment">// 存储用户命令的消息队列</span></span><br><span class="line">	std::mutex mtx; <span class="comment">// 互斥量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">in_msg_que</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i ++ )&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;in_msg_que() running, push data: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			<span class="comment">// 使用 try_to_lock 参数，尝试加锁</span></span><br><span class="line">			<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx, std::try_to_lock)</span></span>;</span><br><span class="line">			<span class="keyword">if</span>(lck.<span class="built_in">owns_lock</span>())&#123;</span><br><span class="line">				<span class="comment">// 尝试后成功拿到了锁</span></span><br><span class="line">				msg_que.<span class="built_in">push</span>(i); </span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">// 没有成功拿到锁，直接返回</span></span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;in_msg_que() running, but cannot get lock: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">out_msg_que</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> command = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i ++ )&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">pop_command</span>(command))&#123;</span><br><span class="line">				<span class="comment">// 消息队列不为空，处理取出的指令</span></span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;out_msg_que() running, command is: &quot;</span> &lt;&lt; command &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">// 消息队列为空</span></span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;out_msg_que() running, queue is empty: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">pop_command</span><span class="params">(<span class="type">int</span>&amp; command)</span></span>&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>; <span class="comment">// 使用 unique_lock 实现自动加锁、解锁</span></span><br><span class="line">		<span class="keyword">if</span>(msg_que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 如果为空，直接返回 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        command = msg_que.<span class="built_in">front</span>(); <span class="comment">// 从队首取出指令</span></span><br><span class="line">		msg_que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MyClass obj;</span><br><span class="line">	<span class="function">std::thread <span class="title">out_msg_t</span><span class="params">(&amp;MyClass::out_msg_que, &amp;obj, <span class="number">10000</span>)</span></span>; </span><br><span class="line">	<span class="function">std::thread <span class="title">in_msg_t</span><span class="params">(&amp;MyClass::in_msg_que, &amp;obj, <span class="number">10000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">out_msg_t</span>.<span class="built_in">join</span>();</span><br><span class="line">	<span class="type">in_msg_t</span>.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>std::defer_lock: 延迟加锁<br>std::adopt_lock:已经拥有了互斥量的锁,管理转移给 std::unique_lock 对象<br>std::try_to_lock:对象并尝试非阻塞地锁定互斥量。如果互斥量当前不可用，它不会阻塞线程，而是直接返回。<br>lck.owns_lock()是否已经有锁</p>
<p>std::timed_mutex 基本概念<br>std::timed_mutex::try_lock_for()<br>std::timed_mutex::try_lock_until()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::timed_mutex t_mtx;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">timeout</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">if</span>(t_mtx.<span class="built_in">try_lock_for</span>(timeout))&#123;</span><br><span class="line">        <span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        std::chrono::duration&lt;<span class="type">double</span>, std::milli&gt; dura = end -start;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;: Successfully get the lock. &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;waiting duration = &quot;</span> &lt;&lt; dura.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms.&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下模拟一些互斥操作</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">15</span>));</span><br><span class="line">        count ++ ;     <span class="comment">// 对共享数据变量进行访问和修改</span></span><br><span class="line">        t_mtx.<span class="built_in">unlock</span>();  <span class="comment">// 解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;threads.<span class="built_in">size</span>();i++)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>std::recursive_mutex 提供了重复（递归）加锁的特性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex r_mtx;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    r_mtx.<span class="built_in">lock</span>();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">dfs</span>(k<span class="number">-1</span>);</span><br><span class="line">    r_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : threads) t = std::<span class="built_in">thread</span>(dfs,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t: threads) t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::shared_mutex 在 C++ 17 被正式引入，是一种互斥量（mutex）类型，包含在 <shared_mutex> 头文件中。<br>std::shared_mutex 提供了两种不同的锁机制，其可以作为 共享锁 使用，也可以作为 独占锁 使用。<br>共享锁 允许多个线程同时对共享数据进行访问，一般用于多个线程读取共享资源的情况。在这种机制下，多个线程可以同时获得互斥量的锁（共享锁），只要对数据的操作仅限于读取。共享锁 可以提高多线程读取数据场景下的并发性能。<br>独占锁 只允许单个线程在同一时刻对共享数据进行操作，一般用于多线程对共享数据进行修改等操作的情况。独占锁 被一个线程占用时，其他线程就无法获得这个锁，直到这个独占锁被释放，以确保数据的一致性。<br>共享锁和独占锁感觉就像是在锁中在分出两个大类，比如先完成a任务才能完成b任务之类的<br>读并发与写阻塞</p>
<p>当有多个读线程获得共享锁时，这些读线程可以并发地对共享资源进行读取操作。此时如果有写线程尝试获取独占锁，这个写线程会被阻塞。</p>
<p>阻塞会一直持续，直到所有当前持有共享锁的读线程都释放了共享锁。</p>
<p>写独占与读阻塞</p>
<p>当一个写线程占有独占锁时，新的读线程尝试获取共享锁会被阻塞。独占锁的优先级高于共享锁。</p>
<p>这种设计是为了防止写操作饥饿（write - starvation）的情况。如果读线程不断地获取共享锁，而写线程一直无法获取独占锁来执行写入操作，这会导致数据不能及时更新。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader_Writer</span>&#123;</span><br><span class="line">    std::shared_mutex s_mtx;  <span class="comment">// 互斥量</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;              <span class="comment">// 共享数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_data</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lck</span><span class="params">(s_mtx)</span></span>; <span class="comment">// 共享锁</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Reader &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; reads the value = &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读者，进行 100 次读操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++ )&#123;</span><br><span class="line">            <span class="built_in">read_data</span>(id);</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write_data</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lck</span><span class="params">(s_mtx)</span></span>; <span class="comment">// 独占锁</span></span><br><span class="line">        val ++ ;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Writer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; writes the value = &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写者，进行 10 次写操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )&#123;</span><br><span class="line">            <span class="built_in">write_data</span>(id);</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Reader_Writer obj;</span><br><span class="line">    <span class="comment">// 创建 10 个读者线程和 2 个写者线程</span></span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">readers</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; readers.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">        readers[i] = std::<span class="built_in">thread</span>(&amp;Reader_Writer::reader, &amp;obj, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">writers</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; writers.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">        writers[i] = std::<span class="built_in">thread</span>(&amp;Reader_Writer::writer, &amp;obj, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; reader : readers) reader.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; writer : writers) writer.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::call_once这个函数模板主要作用是 保证一个函数（可调用对象）在多线程环境下只被调用一次。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::once_flag flag;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::<span class="built_in">call_one</span>(flag,[]()&#123;</span><br><span class="line">        val = <span class="number">1</span> <span class="comment">// 初始化</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者-消费者问题<br>std::condition_variable主要用于 线程间的同步。<br>std::condition_variable::wait() 函数是 std::condition_variable 中的一个关键成员函数，主要用于让线程 等待某个条件成立，通常配合互斥量（mutex）进和 std::unique_lock 使用，以实现线程的同步。<br>使用 wait() 函数时，只能搭配 std::unique_lock 互斥锁使用，不能使用 std::lock_guard。std::condition_variable::wait() 需要在等待期间自动释放互斥量，然后在被唤醒后重新获取互斥量。但是 std::lock_guard 没有提供这样的功能。</p>
<p>std::condition_variable::notify_one() 主要用于当某个条件成立，通知 一个 处于阻塞状态下（等待该条件成立）的线程，进而唤醒这个线程。<br>notify_all()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> PRODUCER_NUM = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CONSUMER_NUM = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> produce_finished_count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> data_num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;data_num;i++)&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mutx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(buffer.<span class="built_in">size</span>() &gt;= BUFFER_SIZE)&#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.<span class="built_in">push</span>(i);</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        produce_finished_count ++;</span><br><span class="line">        <span class="keyword">if</span>(produce_finished_count == PRODUCER_NUM)&#123;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(buffer.<span class="built_in">empty</span>() &amp;&amp; produce_finished_count &lt; PRODUCER_NUM)&#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(buffer.<span class="built_in">empty</span>() &amp;&amp; produce_finished_count == PRODUCER_NUM) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> data = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        lck.<span class="built_in">unlok</span>();</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">producers</span><span class="params">(PRODUCER_NUM)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">consumers</span><span class="params">(CONSUMER_NUM)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i =<span class="number">0</span>;i&lt;producers.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        producers[i] = std::<span class="built_in">thread</span>(producer,i<span class="number">+1</span>,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;consumers.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        consumers[i] = std::<span class="built_in">thread</span>(consumer,i<span class="number">+1</span>,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t: producers) t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t: consumers) t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>异步任务<br>std::async 是 C++ 11 引入的一个函数模板，用于异步地启动一个函数任务。它位于 <future>头文件中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a +b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = std::<span class="built_in">async</span>(std::launch::async, foo, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// std::async 创建异步任务， std::launch::async 异步执行策略（立刻执行）</span></span><br><span class="line">    <span class="keyword">auto</span> data = res.<span class="built_in">get</span>(); <span class="comment">// std::future::get()   异步任务返回值， 一个std::future 只能调用一次，调用完后res就会释放</span></span><br><span class="line">    std::cout&lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//std::async 立即执行分析</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;foo(): thread id =&quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(): starts calculating the res...&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">4</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(): ends calculating the res...&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main(): thread id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = std::<span class="built_in">async</span>(std::launch::async, foo, <span class="number">3</span>, <span class="number">4</span>);<span class="comment">// std::launch</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程 main() 中同时可以做一些其他事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main(): starts doing somethine else...&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main(): ends doing something else...&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> data = res.<span class="built_in">get</span>();<span class="comment">// get() wait() 都能实现阻塞，但是区别是返不返回值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finally get the res = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 直到获取结果才会执行这一句</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Kirisame Marisa.&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//延迟执行分析</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(): thread id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(): starts calculating the res...&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">4</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(): ends calculating the res...&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main(): thread id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个异步任务，std::launch::deferred 会延迟执行 foo()，直到某个调用 get() 或 wait()</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = std::<span class="built_in">async</span>(std::launch::deferred, foo, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程 main() 中同时可以做一些其他事情</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main(): starts doing somethine else...&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main(): ends doing something else...&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) 在主线程中调用 get() 才开始执行 foo()，实际上是在主线程中执行，最后获取结果</span></span><br><span class="line">    <span class="keyword">auto</span> data = res.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finally get the res = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 直到获取结果才会执行这一句</span></span><br><span class="line">    <span class="comment">// (2) 在主线程中调用 get() 才开始执行 foo()，但最后不获取结果</span></span><br><span class="line">    <span class="comment">// res.wait(); </span></span><br><span class="line">    <span class="comment">// (3) 如果前面不调用 get() 或 wait()，foo() 压根不会被执行，会直接输出这一句</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Kirisame Marisa.&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(): thread id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(): starts caculating the res...&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// foo() 需要执行大概 2 秒</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(): ends caculating the res...&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main(): thread id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (1) 创建一个异步任务</span></span><br><span class="line">	<span class="comment">// (1.1) std::launch::async 会立即执行 foo()，wait_for() 可能超时，可能成功获取结果</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; res = std::<span class="built_in">async</span>(std::launch::async, foo, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// (1.2) std::launch::deferred 会延迟执行 foo()，直到某个调用 get() 或 wait()，wait_for() 不起作用</span></span><br><span class="line">    <span class="comment">// std::future&lt;int&gt; res = std::async(std::launch::deferred, foo, 3, 4);</span></span><br><span class="line">	<span class="comment">// (1.3) 默认情况（std::launch::async | std::launch::deferred），则不确定为 (1.1) 还是 (1.2)</span></span><br><span class="line">	<span class="comment">// std::future&lt;int&gt; res = std::async(foo, 3, 4);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> get_data = [&amp;](std::future&lt;<span class="type">int</span>&gt;&amp; res)&#123;</span><br><span class="line">		<span class="keyword">auto</span> data = res.<span class="built_in">get</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;finally get the res = &quot;</span> &lt;&lt; data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// (2) 枚举类型，判断 res 的状态</span></span><br><span class="line">	<span class="comment">// std::future_status status = res.wait_for(std::chrono::seconds(1)); // 等待 1 秒，超时</span></span><br><span class="line">	std::future_status status = res.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>)); <span class="comment">// 等待 3 秒，成功获取结果</span></span><br><span class="line">	<span class="keyword">if</span>(status == std::future_status::timeout)&#123;</span><br><span class="line">		<span class="comment">// (2.1) foo() 还未执行完成，超过等待时间，没有返回结果，超时</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;WARNING: time out&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(status == std::future_status::ready)&#123;</span><br><span class="line">		<span class="comment">// (2.2) foo() 在等待时间内执行完毕，可以获取结果（参数为 std::launch::async）</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;successfully get result.&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="built_in">get_data</span>(res);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(status == std::future_status::deferred)&#123;</span><br><span class="line">		<span class="comment">// (2.3) 参数为 std::launch::deferred 就会出现此情况 </span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;thread is deferred.&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="built_in">get_data</span>(res);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原子操作通常用于多线程开发中，由于其特性使得其可以实现安全的多线程访问，并且不需要担心复杂的线程锁等</p>
<p>1.std::atomic<type></p>
<p>2.std::atomic_flag<br>    1. 类似bool 常量，只有两种状态 ture&amp;false<br>    2. test_and_set()&#x2F;&#x2F; 将 std::atomic_flag 设置为 ture，但是返回值为设置前的状态<br>    3. clear() &#x2F;&#x2F; ture -&gt; false;<br>    4. amtoic_flag 自旋锁机制实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">spinlock_mutex</span>&#123;</span><br><span class="line">    std::atomic_flag flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">spinlock_mutex</span>():<span class="built_in">flag</span>(ATOMIC_FLAG_INIT) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag.<span class="built_in">test_and_set</span>());<span class="comment">// 通过test_and_set 返回的前状态进行检测1.ture就进入while循环等待，2.false跳出等待</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flag.<span class="built_in">clear</span>(); <span class="comment">// 进行解锁将flag：true -&gt;false;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">spinlock_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    count++;</span><br><span class="line">    mtx.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : threads) t = std::<span class="built_in">thread</span>(foo);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : threads) t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>std::atomic<ol>
<li>std::atomic<int> atm(0) &#x2F;&#x2F; &#x3D; atm &#x3D; 0</li>
<li>load() &#x2F;&#x2F; int val &#x3D; atm.load()</li>
<li>store() &#x2F;&#x2F; operator&#x3D; 重载</li>
<li>exchange &#x2F;&#x2F; 注意 atm.exchange(x) 返回的是改变成x前的值，而不是x</li>
</ol>
</li>
</ol>
<p>std::memory_order_relaxed 内存序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atm1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">atm2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> res1 = <span class="number">0</span>; res2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res1 = atm<span class="number">2.l</span>oad(std::memory_order_relaxed);</span><br><span class="line">    atm<span class="number">1.</span><span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_relaxed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res2 = atm<span class="number">1.l</span>oad(std::memory_order_relaxed);</span><br><span class="line">    atm<span class="number">2.</span><span class="built_in">store</span>(<span class="number">1</span>,std::memory_order_relaxed)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(foo1)</span></span></span><br><span class="line"><span class="function">    std::thread <span class="title">t2</span><span class="params">(foo2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    t1.<span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// 因为内存序的问题会有多种res1，res2结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::memory_order_seq_cst 严格的内存顺序。它不仅保证原子操作的原子性，还保证所有使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atm1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">atm2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res1 = atm<span class="number">2.l</span>oad(std::memory_order_seq_cst);</span><br><span class="line">    amt1 = std::<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res2 = atm<span class="number">1.l</span>oad(std::memory_order_seq_cst);</span><br><span class="line">    amt2 = std::<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(foo1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(foo2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="多种方法实现加速求和优化"><a href="#多种方法实现加速求和优化" class="headerlink" title="多种方法实现加速求和优化"></a>多种方法实现加速求和优化</h3><p>std::mutex</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THEEAD = <span class="number">24</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> arr_sum = <span class="number">0</span>;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_sum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =start; i&lt; end;i++) cur_sum += i;</span><br><span class="line">    std::<span class="built_in">lock_guard</span>(std::mutex) <span class="built_in">lck</span>(mtx);</span><br><span class="line">    arr_sum += cur_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">1e9</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr), <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::high_resoultion_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> step = n/NUM_THREAD;</span><br><span class="line">    std::<span class="built_in">vector</span>(std::thread) <span class="built_in">threads</span>(NUM_THEAD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt; NUM_THREAD; i++)&#123;</span><br><span class="line">        <span class="type">int</span> start = i*step;</span><br><span class="line">        <span class="type">int</span> end = (i == NUM_THREADS - <span class="number">1</span>)?n:(i<span class="number">+1</span>)*step;</span><br><span class="line">        threads[i] = std::<span class="built_in">threads</span>(get_sum, std::<span class="built_in">ref</span>(arr),start, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:threads) t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::async 异步任务的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;meteric&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THEADS = <span class="number">24</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> arr_sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get_sum</span><span class="params">(cont std::vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start;i&lt;end;i++)&#123;</span><br><span class="line">        cur_sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num = <span class="number">1e9</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> step = n/NUM_THREADS;</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">futures</span>(NUM_THREADS);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;NUM_THREADS;i++)&#123;</span><br><span class="line">        <span class="type">int</span> start = i * step;</span><br><span class="line">        <span class="type">int</span> end = (i == NUM_THREADS <span class="number">-1</span>)? n; (i<span class="number">+1</span>)*step;</span><br><span class="line">        futures[i] == std::<span class="built_in">sanyc</span>(get_sum, std::<span class="built_in">ref</span>(arr),start, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t: futures)&#123;</span><br><span class="line">        arr_sum += res.<span class="built_in">get</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::promise 异步任务的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">24</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> arr_sum; <span class="comment">// 共享数据变量，数组之和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_sum</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end, </span></span></span><br><span class="line"><span class="params"><span class="function">             std::promise&lt;<span class="type">long</span> <span class="type">long</span>&gt;&amp; pro)</span></span>&#123; <span class="comment">// 传入 promise</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = start; i &lt; end; i ++ )&#123;</span><br><span class="line">        cur_sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pro.<span class="built_in">set_value</span>(cur_sum); <span class="comment">// 设置数组子段结果的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 数组数据输入</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">1e9</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算起始时间点</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个异步任务</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> step = n / NUM_THREADS; <span class="comment">// 每个线程计算的块大小</span></span><br><span class="line">    std::vector&lt;std::promise&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">promises</span>(NUM_THREADS);</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">futures</span>(NUM_THREADS);</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(NUM_THREADS)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> start = i * step;</span><br><span class="line">        <span class="type">int</span> end = (i == NUM_THREADS - <span class="number">1</span>) ? n : (i + <span class="number">1</span>) * step;</span><br><span class="line">        futures[i] = promises[i].<span class="built_in">get_future</span>(); <span class="comment">// 获取关联的 future 对象</span></span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(get_sum, std::<span class="built_in">ref</span>(arr), start, end, std::<span class="built_in">ref</span>(promises[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待每个结果，累加结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; res : futures)&#123;</span><br><span class="line">        arr_sum += res.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads) t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算终止时间点</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>, std::milli&gt; dura = end_time - start_time;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;spend time = &quot;</span> &lt;&lt; dura.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出数组之和</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finally the sum = &quot;</span> &lt;&lt; arr_sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::atomic 原子操作的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">24</span>;</span><br><span class="line">std::atomic&lt;<span class="type">long</span> <span class="type">long</span>&gt; arr_sum; <span class="comment">// 共享数据变量，数组之和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程接口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_sum</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cur_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = start; i &lt; end; i ++ )&#123;</span><br><span class="line">        cur_sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr_sum += cur_sum; <span class="comment">// 原子操作，无需加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 数组数据输入</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = <span class="number">1e9</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::<span class="built_in">iota</span>(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算起始时间点</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> step = n / NUM_THREADS; <span class="comment">// 每个线程计算的块大小</span></span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(NUM_THREADS)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> start = i * step;</span><br><span class="line">        <span class="type">int</span> end = (i == NUM_THREADS - <span class="number">1</span>) ? n : (i + <span class="number">1</span>) * step;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(get_sum, std::<span class="built_in">ref</span>(arr), start, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads) t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算终止时间点</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>, std::milli&gt; dura = end_time - start_time;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;spend time = &quot;</span> &lt;&lt; dura.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;ms.&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出数组之和</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finally the sum = &quot;</span> &lt;&lt; arr_sum &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>; <span class="comment">// 线程执行的函数（任务内容）</span></span><br><span class="line">    <span class="type">bool</span> stop; <span class="comment">// 线程池是否停止标记</span></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks; <span class="comment">// 任务队列，任务被包装为 void function</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads; <span class="comment">// 线程池</span></span><br><span class="line">    std::condition_variable cv; <span class="comment">// 条件变量，用于唤醒等待的线程</span></span><br><span class="line">    std::mutex mtx; <span class="comment">// 互斥量，用于互斥访问标记、任务队列</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，传入线程池中线程数量</span></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> thread_num); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到任务队列函数，返回类型后置（参数：函数，可变参数模板）</span></span><br><span class="line">    <span class="comment">// 传入万能引用，返回一个 std::future 对象（获取结果为 std::result_of&lt;F(Arg...)&gt;::type）</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F&amp;&amp; f, Arg&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Arg...)</span>&gt;::type&gt;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> thread_num): <span class="built_in">stop</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; thread_num; i ++ )&#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(&amp;ThreadPool::work, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>; <span class="comment">// 加锁，互斥访问 stop 标记</span></span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有等待中的线程，线程池已经停止</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有子线程运行完毕</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">joinable</span>())&#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::submit</span><span class="params">(F&amp;&amp; f, Arg&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Arg...)</span>&gt;::type&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 执行 f 函数返回的数据类型</span></span><br><span class="line">    <span class="keyword">using</span> func_type = <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Arg...)&gt;::type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过智能指针，指向函数模板为 func_type() 的包装任务，避免共同访问时被销毁</span></span><br><span class="line">    <span class="comment">// 通过 std::bind 绑定函数、可变参数列表得到一个包装任务</span></span><br><span class="line">    <span class="comment">// std::forward 用于完美转发，将参数以原始的类型（左值或右值）传递</span></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">func_type</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Arg&gt;(args)...)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务到任务队列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(stop)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;ERROR: The thread pool is stoped.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将前面构造好的可调用对象 packaged_task 添加任务队列</span></span><br><span class="line">        tasks.<span class="built_in">emplace</span>([task]()&#123; <span class="comment">// 捕获 task 智能指针</span></span><br><span class="line">            (*task)(); <span class="comment">// 解引用，获取指向的包装任务，并通过()调用这个任务</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒一个等待的线程来执行任务</span></span><br><span class="line">    cv.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 std::future 对象，后续等待获取结果</span></span><br><span class="line">    <span class="keyword">return</span> task -&gt; <span class="built_in">get_future</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程执行的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 定义一个任务</span></span><br><span class="line">        std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从任务队列中取出一个任务</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">while</span>(tasks.<span class="built_in">empty</span>() &amp;&amp; !stop)&#123; <span class="comment">// 避免虚假唤醒</span></span><br><span class="line">                cv.<span class="built_in">wait</span>(lck); <span class="comment">// 需要等待任务进队，线程陷入阻塞</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 可能由于 stop 而退出上面的循环，此时若任务队列为空，直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(tasks.<span class="built_in">empty</span>() &amp;&amp; stop)&#123; <span class="comment">// 任务队列为空且线程池停止</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">            tasks.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;vector&gt;
#include &quot;Thread_Pool.cpp&quot; // 引入线程池
using namespace std;

int main()&#123;
    ThreadPool pool(4); // 创建一个有 4 个线程的线程池

    // 提交一些任务
    vector&lt;pair&lt;future&lt;int&gt;, int&gt;&gt; results; // 存储 future 对象及任务编号
    for(int i = 0; i &lt; 12; i ++ )&#123;
        // 提交任务后，得到 std::future 对象
        auto res = pool.submit([](int x)&#123;
            cout &lt;&lt; &quot;Task &quot; &lt;&lt; x &lt;&lt; &quot;: thread id = &quot; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;\n&quot;;
            return x * x;
        &#125;, i);
        results.emplace_back(move(res), i); // std::future 不可拷贝
    &#125;

    // 获取结果
    for(auto&amp; [res, id] : results)&#123;
        cout &lt;&lt; &quot;Task &quot; &lt;&lt; id &lt;&lt; &quot;: result = &quot; &lt;&lt; res.get() &lt;&lt; &quot;\n&quot;;
    &#125;

    return 0;
&#125;```
## 补充
### 构造函数

## 参考引用
1. [RALL]https://blog.csdn.net/weixin_45031801/article/details/142737361
2. [thread]https://marisamagic.github.io”
</code></pre>
]]></content>
      <categories>
        <category>学习</category>
        <category>高性能C++并行编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>RAII</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出访存优化</title>
    <url>/2025/12/24/%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%80%A7%E8%83%BDC++%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/%5B07%5D%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BF%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="深入浅出访存优化"><a href="#深入浅出访存优化" class="headerlink" title="深入浅出访存优化"></a>深入浅出访存优化</h1><p>time:12_24</p>
<p>结构体的内存布局：AOS 与 SOA<br>AOS（Array of Struct）单个对象的属性紧挨着存<br>SOA（Struct of Array）属性分离存储在多个数组</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>高性能C++并行编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>性能优化</tag>
        <tag>内存访问</tag>
      </tags>
  </entry>
  <entry>
    <title>TBB开启的并行编程之旅</title>
    <url>/2025/12/23/%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%80%A7%E8%83%BDC++%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/%5B06%5DTBB%E5%BC%80%E5%90%AF%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h1 id="TBB-开启的并行编程之旅"><a href="#TBB-开启的并行编程之旅" class="headerlink" title="TBB 开启的并行编程之旅"></a>TBB 开启的并行编程之旅</h1><p>time: 2025-12-23</p>
<h2 id="1-并发与并行：概念与-TBB-的定位"><a href="#1-并发与并行：概念与-TBB-的定位" class="headerlink" title="1. 并发与并行：概念与 TBB 的定位"></a>1. 并发与并行：概念与 TBB 的定位</h2><ul>
<li><strong>并发（Concurrency）</strong>：关注“任务结构”。多个任务在同一时间段内推进即可（单核也能并发）。</li>
<li><strong>并行（Parallelism）</strong>：关注“同时执行”。多个任务在同一时刻运行（通常依赖多核）。</li>
</ul>
<h2 id="2-并发任务：task-group-与-parallel-invoke"><a href="#2-并发任务：task-group-与-parallel-invoke" class="headerlink" title="2. 并发任务：task_group 与 parallel_invoke"></a>2. 并发任务：<code>task_group</code> 与 <code>parallel_invoke</code></h2><h3 id="2-1-task-group：提交多个独立任务"><a href="#2-1-task-group：提交多个独立任务" class="headerlink" title="2.1 task_group：提交多个独立任务"></a>2.1 <code>task_group</code>：提交多个独立任务</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/task_group.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">download</span><span class="params">(<span class="type">const</span> std::string&amp; file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">400</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Downloaded: &quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">interact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::cin &gt;&gt; name;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tbb::task_group tg;</span><br><span class="line">    tg.<span class="built_in">run</span>([&amp;]&#123; <span class="built_in">download</span>(<span class="string">&quot;hello.zip&quot;</span>); &#125;);</span><br><span class="line">    tg.<span class="built_in">run</span>([&amp;]&#123; <span class="built_in">interact</span>(); &#125;);</span><br><span class="line">    tg.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-parallel-invoke：更简洁的并发调用"><a href="#2-2-parallel-invoke：更简洁的并发调用" class="headerlink" title="2.2 parallel_invoke：更简洁的并发调用"></a>2.2 <code>parallel_invoke</code>：更简洁的并发调用</h3><p>当只是“并行执行几个函数”，优先用 <code>parallel_invoke</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_invoke.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">tbb::<span class="built_in">parallel_invoke</span>(</span><br><span class="line">    [&amp;]&#123; <span class="built_in">download</span>(<span class="string">&quot;hello.zip&quot;</span>); &#125;,</span><br><span class="line">    [&amp;]&#123; <span class="built_in">interact</span>(); &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-数据并行：parallel-for-parallel-for-each"><a href="#3-数据并行：parallel-for-parallel-for-each" class="headerlink" title="3. 数据并行：parallel_for &#x2F; parallel_for_each"></a>3. 数据并行：<code>parallel_for</code> &#x2F; <code>parallel_for_each</code></h2><h3 id="3-1-手动分块（task-group）→-推荐替换为-parallel-for"><a href="#3-1-手动分块（task-group）→-推荐替换为-parallel-for" class="headerlink" title="3.1 手动分块（task_group）→ 推荐替换为 parallel_for"></a>3.1 手动分块（<code>task_group</code>）→ 推荐替换为 <code>parallel_for</code></h3><p>手动分块能跑，但属于“自己实现调度”。TBB 风格是把“范围”交给调度器切分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">1u</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(</span><br><span class="line">        tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n),</span><br><span class="line">        [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">                dp[i] = std::<span class="built_in">sinf</span>(<span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-parallel-for-begin-end-body-：最短常用写法"><a href="#3-2-parallel-for-begin-end-body-：最短常用写法" class="headerlink" title="3.2 parallel_for(begin,end,body)：最短常用写法"></a>3.2 <code>parallel_for(begin,end,body)</code>：最短常用写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">1u</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>((<span class="type">size_t</span>)<span class="number">0</span>, n, [&amp;](<span class="type">size_t</span> i)&#123;</span><br><span class="line">        dp[i] = std::<span class="built_in">sinf</span>((<span class="type">float</span>)i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-parallel-for-each：并行遍历容器元素"><a href="#3-3-parallel-for-each：并行遍历容器元素" class="headerlink" title="3.3 parallel_for_each：并行遍历容器元素"></a>3.3 <code>parallel_for_each</code>：并行遍历容器元素</h3><p>语义：对 <code>[first,last)</code> 每个元素并行调用一次 <code>func(element)</code>；要求元素之间无数据冲突。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for_each.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>&lt;&lt;<span class="number">16</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [&amp;](<span class="type">float</span>&amp; f)&#123;</span><br><span class="line">        f = std::<span class="built_in">sinf</span>(f);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-多维并行：blocked-range2d-3d"><a href="#4-多维并行：blocked-range2d-3d" class="headerlink" title="4. 多维并行：blocked_range2d / 3d"></a>4. 多维并行：<code>blocked_range2d / 3d</code></h2><h3 id="4-1-二维：blocked-range2d（rows-cols）"><a href="#4-1-二维：blocked-range2d（rows-cols）" class="headerlink" title="4.1 二维：blocked_range2d（rows&#x2F;cols）"></a>4.1 二维：<code>blocked_range2d</code>（rows&#x2F;cols）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range2d.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">1024</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">a</span><span class="params">(n * n)</span></span>;</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(</span><br><span class="line">        tbb::<span class="built_in">blocked_range2d</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n, <span class="number">0</span>, n),</span><br><span class="line">        [&amp;](<span class="type">const</span> tbb::blocked_range2d&lt;<span class="type">size_t</span>&gt;&amp; r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">rows</span>().<span class="built_in">begin</span>(); i != r.<span class="built_in">rows</span>().<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">size_t</span> j = r.<span class="built_in">cols</span>().<span class="built_in">begin</span>(); j != r.<span class="built_in">cols</span>().<span class="built_in">end</span>(); ++j) &#123;</span><br><span class="line">                    a[i*n + j] = std::<span class="built_in">sinf</span>((<span class="type">float</span>)(i*n + j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-维度记忆"><a href="#4-2-维度记忆" class="headerlink" title="4.2 维度记忆"></a>4.2 维度记忆</h3><ul>
<li>1D：<code>tbb::blocked_range&lt;T&gt;</code></li>
<li>2D：<code>tbb::blocked_range2d&lt;T&gt;</code>：<code>rows()</code>、<code>cols()</code></li>
<li>3D：<code>tbb::blocked_range3d&lt;T&gt;</code>：<code>pages()</code>、<code>rows()</code>、<code>cols()</code></li>
</ul>
<hr>
<h2 id="5-缩并（Reduce）：从“共享变量”到-parallel-reduce"><a href="#5-缩并（Reduce）：从“共享变量”到-parallel-reduce" class="headerlink" title="5. 缩并（Reduce）：从“共享变量”到 parallel_reduce"></a>5. 缩并（Reduce）：从“共享变量”到 <code>parallel_reduce</code></h2><p>当任务存在“跨迭代依赖”（比如求和、统计），不要用共享变量直接累加，会数据竞争或锁开销巨大。<br>标准范式：<strong>局部累加 + 合并</strong>。</p>
<h3 id="5-1-parallel-reduce（lambda-版：最常用）"><a href="#5-1-parallel-reduce（lambda-版：最常用）" class="headerlink" title="5.1 parallel_reduce（lambda 版：最常用）"></a>5.1 <code>parallel_reduce</code>（lambda 版：最常用）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_reduce.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">1u</span> &lt;&lt; <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sum = tbb::<span class="built_in">parallel_reduce</span>(</span><br><span class="line">        tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n),</span><br><span class="line">        <span class="number">0.0f</span>, <span class="comment">// identity</span></span><br><span class="line">        [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r, <span class="type">float</span> local) -&gt; <span class="type">float</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">                local += std::<span class="built_in">sinf</span>((<span class="type">float</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> local;</span><br><span class="line">        &#125;,</span><br><span class="line">        [](<span class="type">float</span> a, <span class="type">float</span> b) -&gt; <span class="type">float</span> &#123; <span class="keyword">return</span> a + b; &#125; <span class="comment">// combine</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-parallel-deterministic-reduce"><a href="#5-2-parallel-deterministic-reduce" class="headerlink" title="5.2 parallel_deterministic_reduce"></a>5.2 <code>parallel_deterministic_reduce</code></h3><p>浮点加法不满足结合律：合并顺序不同，末位可能不同。<br>若需要“每次运行更一致的合并顺序”，可考虑 deterministic 版本（可能略慢）。</p>
<hr>
<h2 id="6-缩并（工程写法）：Reducer-结构体"><a href="#6-缩并（工程写法）：Reducer-结构体" class="headerlink" title="6. 缩并（工程写法）：Reducer 结构体"></a>6. 缩并（工程写法）：Reducer 结构体</h2><p>当归约逻辑变复杂（多个字段、多统计量、希望复用），用结构体 reducer 更稳、更清晰。</p>
<h3 id="6-1-结构体-reducer：并行-sum-sin-i"><a href="#6-1-结构体-reducer：并行-sum-sin-i" class="headerlink" title="6.1 结构体 reducer：并行 sum sin(i)"></a>6.1 结构体 reducer：并行 <code>sum sin(i)</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_reduce.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SinSumReducer</span> &#123;</span><br><span class="line">    <span class="type">float</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SinSumReducer</span>() : <span class="built_in">sum</span>(<span class="number">0.0f</span>) &#123;&#125;                       <span class="comment">// identity</span></span><br><span class="line">    <span class="built_in">SinSumReducer</span>(SinSumReducer&amp;, tbb::split) : <span class="built_in">sum</span>(<span class="number">0.0f</span>) &#123;&#125; <span class="comment">// split ctor</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> local = sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">            local += std::<span class="built_in">sinf</span>((<span class="type">float</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        sum = local;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">const</span> SinSumReducer&amp; rhs)</span> </span>&#123;</span><br><span class="line">        sum += rhs.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">1u</span> &lt;&lt; <span class="number">26</span>;</span><br><span class="line">    SinSumReducer body;</span><br><span class="line">    tbb::<span class="built_in">parallel_reduce</span>(tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), body);</span><br><span class="line">    <span class="type">float</span> result = body.sum;</span><br><span class="line">    (<span class="type">void</span>)result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-多字段统计：sum-min-max-count"><a href="#6-2-多字段统计：sum-min-max-count" class="headerlink" title="6.2 多字段统计：sum &#x2F; min &#x2F; max &#x2F; count"></a>6.2 多字段统计：sum &#x2F; min &#x2F; max &#x2F; count</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_reduce.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StatsReducer</span> &#123;</span><br><span class="line">    <span class="type">double</span> sum;</span><br><span class="line">    <span class="type">float</span>  mn;</span><br><span class="line">    <span class="type">float</span>  mx;</span><br><span class="line">    <span class="type">size_t</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">StatsReducer</span>()</span><br><span class="line">        : <span class="built_in">sum</span>(<span class="number">0.0</span>),</span><br><span class="line">          <span class="built_in">mn</span>(std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>()),</span><br><span class="line">          <span class="built_in">mx</span>(-std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>()),</span><br><span class="line">          <span class="built_in">cnt</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">StatsReducer</span>(StatsReducer&amp;, tbb::split)</span><br><span class="line">        : <span class="built_in">sum</span>(<span class="number">0.0</span>),</span><br><span class="line">          <span class="built_in">mn</span>(std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>()),</span><br><span class="line">          <span class="built_in">mx</span>(-std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>()),</span><br><span class="line">          <span class="built_in">cnt</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;* a = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> s = sum;</span><br><span class="line">        <span class="type">float</span>  lo = mn, hi = mx;</span><br><span class="line">        <span class="type">size_t</span> c = cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">float</span> v = (*a)[i];</span><br><span class="line">            s += v;</span><br><span class="line">            <span class="keyword">if</span> (v &lt; lo) lo = v;</span><br><span class="line">            <span class="keyword">if</span> (v &gt; hi) hi = v;</span><br><span class="line">            ++c;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = s; mn = lo; mx = hi; cnt = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">const</span> StatsReducer&amp; rhs)</span> </span>&#123;</span><br><span class="line">        sum += rhs.sum;</span><br><span class="line">        <span class="keyword">if</span> (rhs.mn &lt; mn) mn = rhs.mn;</span><br><span class="line">        <span class="keyword">if</span> (rhs.mx &gt; mx) mx = rhs.mx;</span><br><span class="line">        cnt += rhs.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1u</span>&lt;&lt;<span class="number">20</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    StatsReducer body;</span><br><span class="line">    body.a = &amp;a;</span><br><span class="line">    tbb::<span class="built_in">parallel_reduce</span>(tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, a.<span class="built_in">size</span>()), body);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// body.sum/body.mn/body.mx/body.cnt</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-线程本地累加器：combinable-enumerable-thread-specific"><a href="#7-线程本地累加器：combinable-enumerable-thread-specific" class="headerlink" title="7. 线程本地累加器：combinable &#x2F; enumerable_thread_specific"></a>7. 线程本地累加器：<code>combinable</code> &#x2F; <code>enumerable_thread_specific</code></h2><p>当模式是“每线程一份局部值，最后合并”，这两者非常实用。</p>
<h3 id="7-1-tbb-combinable（标量-小对象）"><a href="#7-1-tbb-combinable（标量-小对象）" class="headerlink" title="7.1 tbb::combinable&lt;T&gt;（标量&#x2F;小对象）"></a>7.1 <code>tbb::combinable&lt;T&gt;</code>（标量&#x2F;小对象）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/combinable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">1u</span> &lt;&lt; <span class="number">26</span>;</span><br><span class="line">    <span class="function">tbb::combinable&lt;<span class="type">double</span>&gt; <span class="title">tls_sum</span><span class="params">([]&#123; <span class="keyword">return</span> <span class="number">0.0</span>; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>((<span class="type">size_t</span>)<span class="number">0</span>, n, [&amp;](<span class="type">size_t</span> i)&#123;</span><br><span class="line">        tls_sum.<span class="built_in">local</span>() += std::<span class="built_in">sin</span>((<span class="type">double</span>)i);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> sum = tls_sum.<span class="built_in">combine</span>([](<span class="type">double</span> a, <span class="type">double</span> b)&#123; <span class="keyword">return</span> a + b; &#125;);</span><br><span class="line">    (<span class="type">void</span>)sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-tbb-enumerable-thread-specific"><a href="#7-2-tbb-enumerable-thread-specific" class="headerlink" title="7.2 tbb::enumerable_thread_specific&lt;T&gt;"></a>7.2 <code>tbb::enumerable_thread_specific&lt;T&gt;</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/enumerable_thread_specific.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">1u</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 假设值域 [0,255]</span></span><br><span class="line"></span><br><span class="line">    tbb::enumerable_thread_specific&lt;std::vector&lt;<span class="type">size_t</span>&gt;&gt; <span class="built_in">tls_hist</span>(</span><br><span class="line">        []&#123; <span class="keyword">return</span> std::<span class="built_in">vector</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">256</span>, <span class="number">0</span>); &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>((<span class="type">size_t</span>)<span class="number">0</span>, n, [&amp;](<span class="type">size_t</span> i)&#123;</span><br><span class="line">        tls_hist.<span class="built_in">local</span>()[(<span class="type">unsigned</span>)data[i]] += <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">size_t</span>&gt; <span class="title">hist</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; h : tls_hist)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; <span class="number">256</span>; ++b) hist[b] += h[b];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-扫描（Scan）：parallel-scan（前缀和-累计输出）"><a href="#8-扫描（Scan）：parallel-scan（前缀和-累计输出）" class="headerlink" title="8. 扫描（Scan）：parallel_scan（前缀和&#x2F;累计输出）"></a>8. 扫描（Scan）：<code>parallel_scan</code>（前缀和&#x2F;累计输出）</h2><p><code>parallel_scan</code> 常用于：前缀和、累计概率、积分图等。<br>关键机制：两阶段（pre-scan &#x2F; final-scan），用 <code>is_final</code> 控制是否写输出。</p>
<h3 id="8-1-parallel-scan（lambda-版）"><a href="#8-1-parallel-scan（lambda-版）" class="headerlink" title="8.1 parallel_scan（lambda 版）"></a>8.1 <code>parallel_scan</code>（lambda 版）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_scan.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">1u</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">prefix</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> total = tbb::<span class="built_in">parallel_scan</span>(</span><br><span class="line">        tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n),</span><br><span class="line">        <span class="number">0.0f</span>,</span><br><span class="line">        [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r, <span class="type">float</span> running, <span class="type">bool</span> is_final) -&gt; <span class="type">float</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">                running += std::<span class="built_in">sinf</span>((<span class="type">float</span>)i);</span><br><span class="line">                <span class="keyword">if</span> (is_final) prefix[i] = running;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> running;</span><br><span class="line">        &#125;,</span><br><span class="line">        [](<span class="type">float</span> a, <span class="type">float</span> b) -&gt; <span class="type">float</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; prefix[n/<span class="number">2</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-parallel-scan（结构体版：工程范式）"><a href="#8-2-parallel-scan（结构体版：工程范式）" class="headerlink" title="8.2 parallel_scan（结构体版：工程范式）"></a>8.2 <code>parallel_scan</code>（结构体版：工程范式）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_scan.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PrefixScanBody</span> &#123;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; in;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt;&amp; out;</span><br><span class="line">    <span class="type">float</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrefixScanBody</span>(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; in_, std::vector&lt;<span class="type">float</span>&gt;&amp; out_)</span><br><span class="line">        : <span class="built_in">in</span>(in_), <span class="built_in">out</span>(out_), <span class="built_in">sum</span>(<span class="number">0.0f</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrefixScanBody</span>(PrefixScanBody&amp; b, tbb::split)</span><br><span class="line">        : <span class="built_in">in</span>(b.in), <span class="built_in">out</span>(b.out), <span class="built_in">sum</span>(<span class="number">0.0f</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tag&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r, Tag)</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> temp = sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">            temp += in[i];</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;Tag, tbb::final_scan_tag&gt;)</span> </span>&#123;</span><br><span class="line">                out[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse_join</span><span class="params">(PrefixScanBody&amp; rhs)</span> </span>&#123; sum += rhs.sum; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(PrefixScanBody&amp; rhs)</span>       </span>&#123; sum  = rhs.sum; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">1u</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">in</span><span class="params">(n, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">out</span><span class="params">(n, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">PrefixScanBody <span class="title">body</span><span class="params">(in, out)</span></span>;</span><br><span class="line">    tbb::<span class="built_in">parallel_scan</span>(tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), body);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-任务域与嵌套：task-arena-isolate"><a href="#9-任务域与嵌套：task-arena-isolate" class="headerlink" title="9. 任务域与嵌套：task_arena &#x2F; isolate"></a>9. 任务域与嵌套：<code>task_arena</code> &#x2F; <code>isolate</code></h2><h3 id="9-1-task-arena：限制并行度-隔离并行区域"><a href="#9-1-task-arena：限制并行度-隔离并行区域" class="headerlink" title="9.1 task_arena：限制并行度 &#x2F; 隔离并行区域"></a>9.1 <code>task_arena</code>：限制并行度 &#x2F; 隔离并行区域</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/task_arena.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">1u</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">tbb::task_arena <span class="title">arena</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 该区域最多 4 个线程参与</span></span><br><span class="line">    arena.<span class="built_in">execute</span>([&amp;]&#123;</span><br><span class="line">        tbb::<span class="built_in">parallel_for</span>((<span class="type">size_t</span>)<span class="number">0</span>, n, [&amp;](<span class="type">size_t</span> i)&#123;</span><br><span class="line">            a[i] = std::<span class="built_in">sinf</span>((<span class="type">float</span>)i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-this-task-arena-isolate：禁止内部任务被窃取（隔离干扰）"><a href="#9-2-this-task-arena-isolate：禁止内部任务被窃取（隔离干扰）" class="headerlink" title="9.2 this_task_arena::isolate：禁止内部任务被窃取（隔离干扰）"></a>9.2 <code>this_task_arena::isolate</code>：禁止内部任务被窃取（隔离干扰）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/this_task_arena.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">tbb::this_task_arena::<span class="built_in">isolate</span>([&amp;]&#123;</span><br><span class="line">    <span class="comment">// 这里 spawn 的任务更隔离，不易跨域被 steal</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实务提醒：嵌套并行时不要依赖“线程固定&#x2F;执行路径固定”。更推荐减少共享状态、用 reduce&#x2F;tls 合并，或用 arena&#x2F;isolate 控制并行边界。</p>
</blockquote>
<hr>
<h2 id="10-分块策略（Partitioner）：性能与可预测性"><a href="#10-分块策略（Partitioner）：性能与可预测性" class="headerlink" title="10. 分块策略（Partitioner）：性能与可预测性"></a>10. 分块策略（Partitioner）：性能与可预测性</h2><p>TBB 切分范围时可以指定 partitioner：</p>
<ul>
<li><code>tbb::static_partitioner</code>：划分更固定、可预测</li>
<li><code>tbb::affinity_partitioner</code>：记录历史映射，提高缓存命中（适合重复执行的相似循环）</li>
<li><code>tbb::simple_partitioner</code>：简单切分策略</li>
</ul>
<p>示例：观察每个线程拿到的块</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/task_arena.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/this_task_arena.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = <span class="number">32</span>;</span><br><span class="line">    <span class="function">tbb::task_arena <span class="title">arena</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    arena.<span class="built_in">execute</span>([&amp;]&#123;</span><br><span class="line">        tbb::<span class="built_in">parallel_for</span>(</span><br><span class="line">            tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n),</span><br><span class="line">            [&amp;](<span class="type">const</span> tbb::blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)&#123;</span><br><span class="line">                std::cout</span><br><span class="line">                    &lt;&lt; <span class="string">&quot;tid=&quot;</span> &lt;&lt; tbb::this_task_arena::<span class="built_in">current_thread_index</span>()</span><br><span class="line">                    &lt;&lt; <span class="string">&quot; range=[&quot;</span> &lt;&lt; r.<span class="built_in">begin</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; r.<span class="built_in">end</span>() &lt;&lt; <span class="string">&quot;)&quot;</span></span><br><span class="line">                    &lt;&lt; <span class="string">&quot; size=&quot;</span> &lt;&lt; r.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            tbb::static_partitioner&#123;&#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="11-全局并行度控制：global-control（工程常用）"><a href="#11-全局并行度控制：global-control（工程常用）" class="headerlink" title="11. 全局并行度控制：global_control（工程常用）"></a>11. 全局并行度控制：<code>global_control</code>（工程常用）</h2><p>当你不希望 TBB “吃满所有核”，可全局限制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/global_control.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">tbb::global_control <span class="title">gc</span><span class="params">(tbb::global_control::max_allowed_parallelism, <span class="number">8</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 后续 TBB 并行算法最多使用 8 个线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="12-并发容器：concurrent-vector"><a href="#12-并发容器：concurrent-vector" class="headerlink" title="12. 并发容器：concurrent_vector"></a>12. 并发容器：<code>concurrent_vector</code></h2><p>特点：并发 push 更友好，但实现上可能是分段存储，不等同于 <code>std::vector</code> 的严格连续内存语义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/concurrent_vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tbb::concurrent_vector&lt;std::string&gt; out;</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>(<span class="number">0</span>, <span class="number">1000</span>, [&amp;](<span class="type">int</span> i)&#123;</span><br><span class="line">        out.<span class="built_in">push_back</span>(<span class="string">&quot;item_&quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="13-流水线并行：parallel-pipeline（I-O-compute-的标准解法）"><a href="#13-流水线并行：parallel-pipeline（I-O-compute-的标准解法）" class="headerlink" title="13. 流水线并行：parallel_pipeline（I&#x2F;O + compute 的标准解法）"></a>13. 流水线并行：<code>parallel_pipeline</code>（I&#x2F;O + compute 的标准解法）</h2><p>适用：读入→解析→计算→写出，多阶段、不同并行度需求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_pipeline.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/flow_control.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_pipeline</span>(</span><br><span class="line">        <span class="number">4</span>, <span class="comment">// max live tokens</span></span><br><span class="line"></span><br><span class="line">        tbb::<span class="built_in">make_filter</span>&lt;<span class="type">void</span>, <span class="type">int</span>&gt;(</span><br><span class="line">            tbb::filter_mode::serial_in_order,</span><br><span class="line">            [&amp;](tbb::flow_control&amp; fc) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">20</span>) &#123; fc.<span class="built_in">stop</span>(); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">                <span class="keyword">return</span> x++;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        &amp;</span><br><span class="line">        tbb::<span class="built_in">make_filter</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(</span><br><span class="line">            tbb::filter_mode::parallel,</span><br><span class="line">            [&amp;](<span class="type">int</span> v) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> v * v; <span class="comment">// heavy compute</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        &amp;</span><br><span class="line">        tbb::<span class="built_in">make_filter</span>&lt;<span class="type">int</span>, <span class="type">void</span>&gt;(</span><br><span class="line">            tbb::filter_mode::serial_in_order,</span><br><span class="line">            [&amp;](<span class="type">int</span> y) &#123;</span><br><span class="line">                std::cout &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://en.cppreference.com/w/cpp/language/access.html?utm_source=chatgpt.com">https://en.cppreference.com/w/cpp/language/access.html?utm_source=chatgpt.com</a><br><a href="https://en.cppreference.com/w/cpp/language/operators.html?utm_source=chatgpt.com">https://en.cppreference.com/w/cpp/language/operators.html?utm_source=chatgpt.com</a><br><a href="https://mooshak.dcc.fc.up.pt/~oni-judge/doc/cppreference/reference/en/cpp/language/constructor.html?utm_source=chatgpt.com">https://mooshak.dcc.fc.up.pt/~oni-judge/doc/cppreference/reference/en/cpp/language/constructor.html?utm_source=chatgpt.com</a></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>高性能C++并行编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>TBB</tag>
        <tag>并行编程</tag>
      </tags>
  </entry>
  <entry>
    <title>流体仿真实战</title>
    <url>/2026/01/06/%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%80%A7%E8%83%BDC++%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/%5B9%5D%E6%B5%81%E4%BD%93%E4%BB%BF%E7%9C%9F%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="流体仿真实战"><a href="#流体仿真实战" class="headerlink" title="流体仿真实战"></a>流体仿真实战</h1><p>time: 2026_1_6</p>
<h2 id="CUDA-纹理对象"><a href="#CUDA-纹理对象" class="headerlink" title="CUDA 纹理对象"></a>CUDA 纹理对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct DisableCopy&#123;</span><br><span class="line">    DisableCopy() = defauly;</span><br><span class="line">    DIsableCopy(DisableCopy const &amp;) = delete;</span><br><span class="line">    DIsableCopy &amp;operator-&gt;(DisableCopy const &amp;) = delete;</span><br><span class="line">&#125;</span><br><span class="line">te</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>高性能C++并行编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>并行编程</tag>
        <tag>流体模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA开启的GPU编程</title>
    <url>/2026/01/04/%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%80%A7%E8%83%BDC++%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/%5B08%5DCUDA%E5%BC%80%E5%90%AF%E7%9A%84GPU%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="CUDA-开启的-GPU-编程"><a href="#CUDA-开启的-GPU-编程" class="headerlink" title="CUDA 开启的 GPU 编程"></a>CUDA 开启的 GPU 编程</h1><p>time：2025_12_26</p>
<hr>
<h2 id="1-工程与编译（CMake-nvcc）"><a href="#1-工程与编译（CMake-nvcc）" class="headerlink" title="1. 工程与编译（CMake &#x2F; nvcc）"></a>1. 工程与编译（CMake &#x2F; nvcc）</h2><h3 id="1-1-最小-CMake-工程"><a href="#1-1-最小-CMake-工程" class="headerlink" title="1.1 最小 CMake 工程"></a>1.1 最小 CMake 工程</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.18</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocuda LANGUAGES CXX CUDA)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cu)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(main PROPERTIES</span><br><span class="line">  CUDA_STANDARD <span class="number">17</span></span><br><span class="line">  CUDA_STANDARD_REQUIRED <span class="keyword">ON</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要跨 .cu 调用 device 函数/做 device link 时开启</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(main PROPERTIES CUDA_SEPARABLE_COMPILATION <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用 CUDA 编译选项（按需启用）</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(main PUBLIC</span><br><span class="line">  $&lt;$&lt;COMPILE_LANGUAGE:CUDA&gt;:--expt-relaxed-constexpr&gt;</span><br><span class="line">  $&lt;$&lt;COMPILE_LANGUAGE:CUDA&gt;:--expt-extended-lambda&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-推荐的基础错误检查宏"><a href="#1-2-推荐的基础错误检查宏" class="headerlink" title="1.2 推荐的基础错误检查宏"></a>1.2 推荐的基础错误检查宏</h3><p>避免依赖 sample 的 <code>helper_cuda.h</code>，直接自带一个最小版：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CUDA_CHECK(call) do &#123;                                  \</span></span><br><span class="line"><span class="meta">  cudaError_t err = (call);                                    \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (err != cudaSuccess) &#123;                                    \</span></span><br><span class="line"><span class="meta">    std::fprintf(stderr, <span class="string">&quot;CUDA error %s:%d: %s\n&quot;</span>,             \</span></span><br><span class="line"><span class="meta">      __FILE__, __LINE__, cudaGetErrorString(err));            \</span></span><br><span class="line"><span class="meta">    std::exit(1);                                              \</span></span><br><span class="line"><span class="meta">  &#125;                                                            \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-CUDA-基础：函数修饰符与执行位置"><a href="#2-CUDA-基础：函数修饰符与执行位置" class="headerlink" title="2. CUDA 基础：函数修饰符与执行位置"></a>2. CUDA 基础：函数修饰符与执行位置</h2><h3 id="2-1-global-device-host"><a href="#2-1-global-device-host" class="headerlink" title="2.1 __global__ / __device__ / __host__"></a>2.1 <code>__global__ / __device__ / __host__</code></h3><ul>
<li><p><code>__global__</code>：核函数（kernel）</p>
<ul>
<li>在 GPU 上并行执行</li>
<li>由主机端（CPU）发起 <code>&lt;&lt;&lt;...&gt;&gt;&gt;</code></li>
<li>返回类型必须为 <code>void</code>（通常通过指针写回结果）</li>
</ul>
</li>
<li><p><code>__device__</code>：设备函数</p>
<ul>
<li>在 GPU 上执行</li>
<li>只能从 device&#x2F;global 调用</li>
</ul>
</li>
<li><p><code>__host__</code>：主机函数</p>
<ul>
<li>在 CPU 上执行</li>
<li>未标注的普通函数默认就是 host</li>
</ul>
</li>
</ul>
<p>组合：</p>
<ul>
<li><code>__host__ __device__</code>：同一函数在 CPU&#x2F;GPU 两侧都可用（注意 device 侧不支持完整的 C++ 标准库能力）</li>
</ul>
<h3 id="2-2-CUDA-ARCH-（区分-device-host-编译路径）"><a href="#2-2-CUDA-ARCH-（区分-device-host-编译路径）" class="headerlink" title="2.2 __CUDA_ARCH__（区分 device&#x2F;host 编译路径）"></a>2.2 <code>__CUDA_ARCH__</code>（区分 device&#x2F;host 编译路径）</h3><ul>
<li><code>__CUDA_ARCH__</code> 只在 device 编译路径中定义，值为计算能力架构号（例如 750&#x2F;800 等）</li>
<li>常用于同一个函数在 host&#x2F;device 的条件编译</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__host__ __device__ inline int where_am_i() &#123;</span><br><span class="line">#ifdef __CUDA_ARCH__</span><br><span class="line">    return __CUDA_ARCH__;   // device：架构号</span><br><span class="line">#else</span><br><span class="line">    return -1;              // host：标记</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-constexpr-与-device-代码"><a href="#2-3-constexpr-与-device-代码" class="headerlink" title="2.3 constexpr 与 device 代码"></a>2.3 <code>constexpr</code> 与 device 代码</h3><ul>
<li>如需更宽松的 <code>constexpr</code> 在 device 侧工作，常用 <code>--expt-relaxed-constexpr</code></li>
<li>device 侧 lambda 扩展常用 <code>--expt-extended-lambda</code></li>
</ul>
<hr>
<h2 id="3-Kernel-启动、线程块模型与索引"><a href="#3-Kernel-启动、线程块模型与索引" class="headerlink" title="3. Kernel 启动、线程块模型与索引"></a>3. Kernel 启动、线程块模型与索引</h2><h3 id="3-1-Kernel-启动语法"><a href="#3-1-Kernel-启动语法" class="headerlink" title="3.1 Kernel 启动语法"></a>3.1 Kernel 启动语法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kernel&lt;&lt;&lt;grid, block, shared_bytes, stream&gt;&gt;&gt;(args...);</span><br></pre></td></tr></table></figure>

<ul>
<li>常用：<code>&lt;&lt;&lt;grid, block&gt;&gt;&gt;</code></li>
<li><code>shared_bytes</code>：动态共享内存字节数（默认 0）</li>
<li><code>stream</code>：CUDA 流（默认 0）</li>
</ul>
<h3 id="3-2-线程-块索引"><a href="#3-2-线程-块索引" class="headerlink" title="3.2 线程&#x2F;块索引"></a>3.2 线程&#x2F;块索引</h3><ul>
<li><code>threadIdx.&#123;x,y,z&#125;</code>：线程在块内索引</li>
<li><code>blockIdx.&#123;x,y,z&#125;</code>：块在网格内索引</li>
<li><code>blockDim.&#123;x,y,z&#125;</code>：每块线程数维度</li>
<li><code>gridDim.&#123;x,y,z&#125;</code>：网格块数维度</li>
</ul>
<h3 id="3-3-典型打印示例（便于理解执行模型）"><a href="#3-3-典型打印示例（便于理解执行模型）" class="headerlink" title="3.3 典型打印示例（便于理解执行模型）"></a>3.3 典型打印示例（便于理解执行模型）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cuda_runtime.h&gt;</span><br><span class="line"></span><br><span class="line">__global__ void kernel() &#123;</span><br><span class="line">    printf(&quot;block %d/%d, thread %d/%d\n&quot;,</span><br><span class="line">           blockIdx.x, gridDim.x,</span><br><span class="line">           threadIdx.x, blockDim.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    kernel&lt;&lt;&lt;2, 3&gt;&gt;&gt;();</span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-Grid-Stride-Loop（通用遍历范式）"><a href="#3-4-Grid-Stride-Loop（通用遍历范式）" class="headerlink" title="3.4 Grid-Stride Loop（通用遍历范式）"></a>3.4 Grid-Stride Loop（通用遍历范式）</h3><p>适用于任意大小数据与任意 grid&#x2F;block 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__global__ void work(int* a, int n) &#123;</span><br><span class="line">    for (int i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">         i &lt; n;</span><br><span class="line">         i += blockDim.x * gridDim.x) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-同步与错误处理"><a href="#4-同步与错误处理" class="headerlink" title="4. 同步与错误处理"></a>4. 同步与错误处理</h2><h3 id="4-1-CPU-GPU-默认异步"><a href="#4-1-CPU-GPU-默认异步" class="headerlink" title="4.1 CPU&#x2F;GPU 默认异步"></a>4.1 CPU&#x2F;GPU 默认异步</h3><ul>
<li><p>kernel launch 对 host 来说通常是异步的</p>
</li>
<li><p>常用同步：</p>
<ul>
<li><code>cudaDeviceSynchronize()</code>：等待当前设备上所有已提交工作完成</li>
<li><code>cudaStreamSynchronize(stream)</code>：等待某个流完成</li>
</ul>
</li>
</ul>
<h3 id="4-2-推荐的-launch-后检查模板"><a href="#4-2-推荐的-launch-后检查模板" class="headerlink" title="4.2 推荐的 launch 后检查模板"></a>4.2 推荐的 launch 后检查模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(...);</span><br><span class="line"><span class="built_in">CUDA_CHECK</span>(<span class="built_in">cudaGetLastError</span>());</span><br><span class="line"><span class="built_in">CUDA_CHECK</span>(<span class="built_in">cudaDeviceSynchronize</span>());</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-内存管理（Host-Device-Unified）"><a href="#5-内存管理（Host-Device-Unified）" class="headerlink" title="5. 内存管理（Host&#x2F;Device&#x2F;Unified）"></a>5. 内存管理（Host&#x2F;Device&#x2F;Unified）</h2><h3 id="5-1-经典模式：cudaMalloc-cudaMemcpy"><a href="#5-1-经典模式：cudaMalloc-cudaMemcpy" class="headerlink" title="5.1 经典模式：cudaMalloc + cudaMemcpy"></a>5.1 经典模式：<code>cudaMalloc + cudaMemcpy</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cuda_runtime.h&gt;</span><br><span class="line"></span><br><span class="line">#define CUDA_CHECK(call) do &#123; \</span><br><span class="line">  cudaError_t err = (call); \</span><br><span class="line">  if (err != cudaSuccess) &#123; \</span><br><span class="line">    std::fprintf(stderr, &quot;CUDA error: %s\n&quot;, cudaGetErrorString(err)); \</span><br><span class="line">    std::exit(1); \</span><br><span class="line">  &#125; \</span><br><span class="line">&#125; while(0)</span><br><span class="line"></span><br><span class="line">__global__ void kernel(int* out) &#123; *out = 42; &#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int* d_out = nullptr;</span><br><span class="line">    CUDA_CHECK(cudaMalloc(&amp;d_out, sizeof(int)));</span><br><span class="line"></span><br><span class="line">    kernel&lt;&lt;&lt;1,1&gt;&gt;&gt;(d_out);</span><br><span class="line">    CUDA_CHECK(cudaGetLastError());</span><br><span class="line">    CUDA_CHECK(cudaDeviceSynchronize());</span><br><span class="line"></span><br><span class="line">    int h_out = 0;</span><br><span class="line">    CUDA_CHECK(cudaMemcpy(&amp;h_out, d_out, sizeof(int), cudaMemcpyDeviceToHost));</span><br><span class="line"></span><br><span class="line">    std::printf(&quot;ret=%d\n&quot;, h_out);</span><br><span class="line"></span><br><span class="line">    CUDA_CHECK(cudaFree(d_out));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-统一内存（Unified-Memory）：cudaMallocManaged"><a href="#5-2-统一内存（Unified-Memory）：cudaMallocManaged" class="headerlink" title="5.2 统一内存（Unified Memory）：cudaMallocManaged"></a>5.2 统一内存（Unified Memory）：<code>cudaMallocManaged</code></h3><ul>
<li>一份指针同时可被 CPU&#x2F;GPU 访问</li>
<li>常配合同步；性能敏感时可用预取提升稳定性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cuda_runtime.h&gt;</span><br><span class="line"></span><br><span class="line">__global__ void fill(int* a, int n) &#123;</span><br><span class="line">    for (int i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">         i &lt; n; i += blockDim.x * gridDim.x) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 32;</span><br><span class="line">    int* a = nullptr;</span><br><span class="line">    cudaMallocManaged(&amp;a, sizeof(int) * n);</span><br><span class="line"></span><br><span class="line">    fill&lt;&lt;&lt;1, 128&gt;&gt;&gt;(a, n);</span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) std::printf(&quot;a[%d]=%d\n&quot;, i, a[i]);</span><br><span class="line">    cudaFree(a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-预取（Prefetch）与驻留优化（进阶但常用）"><a href="#5-3-预取（Prefetch）与驻留优化（进阶但常用）" class="headerlink" title="5.3 预取（Prefetch）与驻留优化（进阶但常用）"></a>5.3 预取（Prefetch）与驻留优化（进阶但常用）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dev = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cudaGetDevice</span>(&amp;dev);</span><br><span class="line"><span class="built_in">cudaMemPrefetchAsync</span>(a, <span class="built_in">sizeof</span>(<span class="type">int</span>)*n, dev, <span class="number">0</span>);     <span class="comment">// 预取到 GPU</span></span><br><span class="line"><span class="comment">// kernel ...</span></span><br><span class="line"><span class="built_in">cudaMemPrefetchAsync</span>(a, <span class="built_in">sizeof</span>(<span class="type">int</span>)*n, cudaCpuDeviceId, <span class="number">0</span>); <span class="comment">// 预取回 CPU</span></span><br><span class="line"><span class="built_in">cudaDeviceSynchronize</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-C-封装：RAII-与可复用接口"><a href="#6-C-封装：RAII-与可复用接口" class="headerlink" title="6. C++ 封装：RAII 与可复用接口"></a>6. C++ 封装：RAII 与可复用接口</h2><h3 id="6-1-RAII-管理-Unified-Memory-指针（简单、可靠、适合入门）"><a href="#6-1-RAII-管理-Unified-Memory-指针（简单、可靠、适合入门）" class="headerlink" title="6.1 RAII 管理 Unified Memory 指针（简单、可靠、适合入门）"></a>6.1 RAII 管理 Unified Memory 指针（简单、可靠、适合入门）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda_runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ManagedArray</span> &#123;</span><br><span class="line">    T* p&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> n&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ManagedArray</span><span class="params">(<span class="type">size_t</span> n_)</span> : n(n_) &#123;</span></span><br><span class="line">        <span class="built_in">cudaMallocManaged</span>(&amp;p, <span class="built_in">sizeof</span>(T) * n);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ManagedArray</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="built_in">cudaFree</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> T* <span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> i) &#123; <span class="keyword">return</span> p[i]; &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> i) <span class="type">const</span> &#123; <span class="keyword">return</span> p[i]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-结合-kernel-使用"><a href="#6-2-结合-kernel-使用" class="headerlink" title="6.2 结合 kernel 使用"></a>6.2 结合 kernel 使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__global__ void init(int* a, int n) &#123;</span><br><span class="line">    for (int i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">         i &lt; n; i += blockDim.x * gridDim.x) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 1000;</span><br><span class="line">    ManagedArray&lt;int&gt; a(n);</span><br><span class="line">    init&lt;&lt;&lt;32, 128&gt;&gt;&gt;(a.data(), n);</span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line">    // CPU 侧直接读</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>allocator 方式也可把 unified memory 接入 <code>std::vector</code>，但 allocator 细节较多；建议先把 RAII 指针与 <code>.data()</code> 传参掌握牢。</p>
</blockquote>
<hr>
<h2 id="7-Thrust-库：容器与算法（高层-CUDA）"><a href="#7-Thrust-库：容器与算法（高层-CUDA）" class="headerlink" title="7. Thrust 库：容器与算法（高层 CUDA）"></a>7. Thrust 库：容器与算法（高层 CUDA）</h2><h3 id="7-1-常用容器"><a href="#7-1-常用容器" class="headerlink" title="7.1 常用容器"></a>7.1 常用容器</h3><ul>
<li><code>thrust::host_vector&lt;T&gt;</code>：主机端 vector</li>
<li><code>thrust::device_vector&lt;T&gt;</code>：设备端 vector</li>
<li>通过赋值可触发 H2D &#x2F; D2H 拷贝（更准确地说：构造&#x2F;赋值会在 host&#x2F;device 容器之间进行数据迁移）</li>
</ul>
<h3 id="7-2-AXPY-示例（device-vector-自写-kernel）"><a href="#7-2-AXPY-示例（device-vector-自写-kernel）" class="headerlink" title="7.2 AXPY 示例（device_vector + 自写 kernel）"></a>7.2 AXPY 示例（device_vector + 自写 kernel）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;thrust/host_vector.h&gt;</span><br><span class="line">#include &lt;thrust/device_vector.h&gt;</span><br><span class="line">#include &lt;cuda_runtime.h&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">__global__ void axpy(float* x, const float* y, float a, int n) &#123;</span><br><span class="line">    for (int i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">         i &lt; n; i += blockDim.x * gridDim.x) &#123;</span><br><span class="line">        x[i] = a * x[i] + y[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 1 &lt;&lt; 20;</span><br><span class="line">    float a = 3.14f;</span><br><span class="line"></span><br><span class="line">    thrust::host_vector&lt;float&gt; hx(n), hy(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123; hx[i] = i * 0.001f; hy[i] = 1.0f; &#125;</span><br><span class="line"></span><br><span class="line">    thrust::device_vector&lt;float&gt; dx = hx;</span><br><span class="line">    thrust::device_vector&lt;float&gt; dy = hy;</span><br><span class="line"></span><br><span class="line">    axpy&lt;&lt;&lt;256, 256&gt;&gt;&gt;(thrust::raw_pointer_cast(dx.data()),</span><br><span class="line">                       thrust::raw_pointer_cast(dy.data()),</span><br><span class="line">                       a, n);</span><br><span class="line">    cudaDeviceSynchronize();</span><br><span class="line"></span><br><span class="line">    hx = dx;</span><br><span class="line">    std::printf(&quot;hx[0]=%f, hx[n-1]=%f\n&quot;, hx[0], hx[n-1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-原子操作（Atomic）"><a href="#8-原子操作（Atomic）" class="headerlink" title="8. 原子操作（Atomic）"></a>8. 原子操作（Atomic）</h2><h3 id="8-1-常用原子"><a href="#8-1-常用原子" class="headerlink" title="8.1 常用原子"></a>8.1 常用原子</h3><ul>
<li><code>atomicAdd / atomicSub</code></li>
<li><code>atomicAnd / atomicOr / atomicXor</code></li>
<li><code>atomicMin / atomicMax</code></li>
<li><code>atomicCAS</code>：Compare-And-Swap，可用于构造自定义原子操作</li>
</ul>
<h3 id="8-2-用-CAS-实现自定义原子加"><a href="#8-2-用-CAS-实现自定义原子加" class="headerlink" title="8.2 用 CAS 实现自定义原子加"></a>8.2 用 CAS 实现自定义原子加</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__device__ __forceinline__ int my_atomic_add(int* dst, int val) &#123;</span><br><span class="line">    int old = *dst;</span><br><span class="line">    int assumed;</span><br><span class="line">    do &#123;</span><br><span class="line">        assumed = old;</span><br><span class="line">        old = atomicCAS(dst, assumed, assumed + val);</span><br><span class="line">    &#125; while (assumed != old);</span><br><span class="line">    return old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-朴素并行求和（全局原子累加）"><a href="#8-3-朴素并行求和（全局原子累加）" class="headerlink" title="8.3 朴素并行求和（全局原子累加）"></a>8.3 朴素并行求和（全局原子累加）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__global__ void parallel_sum(int* sum, const int* arr, int n) &#123;</span><br><span class="line">    for (int i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">         i &lt; n; i += blockDim.x * gridDim.x) &#123;</span><br><span class="line">        atomicAdd(sum, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-线程块与共享内存（Shared-Memory）"><a href="#9-线程块与共享内存（Shared-Memory）" class="headerlink" title="9. 线程块与共享内存（Shared Memory）"></a>9. 线程块与共享内存（Shared Memory）</h2><h3 id="9-1-核心概念"><a href="#9-1-核心概念" class="headerlink" title="9.1 核心概念"></a>9.1 核心概念</h3><ul>
<li><code>__shared__</code>：块内共享内存（一个 block 内所有线程可见）</li>
<li><code>__syncthreads()</code>：块内同步屏障（必须保证同一 block 的线程都能到达）</li>
</ul>
<p>共享内存常用于：</p>
<ul>
<li>块内复用数据（减少 global memory 访问）</li>
<li>块内归约（reduce）</li>
<li>tile-based 计算（矩阵乘、卷积、图像算子）</li>
</ul>
<h3 id="9-2-块内归约：每块只做一次全局原子"><a href="#9-2-块内归约：每块只做一次全局原子" class="headerlink" title="9.2 块内归约：每块只做一次全局原子"></a>9.2 块内归约：每块只做一次全局原子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cuda_runtime.h&gt;</span><br><span class="line"></span><br><span class="line">__global__ void reduce_sum(const int* arr, int n, int* out) &#123;</span><br><span class="line">    extern __shared__ int sdata[]; // 动态共享内存</span><br><span class="line">    int tid = threadIdx.x;</span><br><span class="line">    int i = blockIdx.x * blockDim.x + tid;</span><br><span class="line"></span><br><span class="line">    sdata[tid] = (i &lt; n) ? arr[i] : 0;</span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    for (int s = blockDim.x / 2; s &gt; 0; s &gt;&gt;= 1) &#123;</span><br><span class="line">        if (tid &lt; s) sdata[tid] += sdata[tid + s];</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tid == 0) atomicAdd(out, sdata[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动方式（动态共享内存大小）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> threads = <span class="number">256</span>;</span><br><span class="line"><span class="type">int</span> blocks = (n + threads - <span class="number">1</span>) / threads;</span><br><span class="line">reduce_sum&lt;&lt;&lt;blocks, threads, <span class="function">threads * <span class="title">sizeof</span><span class="params">(<span class="type">int</span>)</span>&gt;&gt;&gt;<span class="params">(arr, n, out)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-Tile-示例：2D-图像-3x3-均值滤波（共享内存加速范式）"><a href="#9-3-Tile-示例：2D-图像-3x3-均值滤波（共享内存加速范式）" class="headerlink" title="9.3 Tile 示例：2D 图像 3x3 均值滤波（共享内存加速范式）"></a>9.3 Tile 示例：2D 图像 3x3 均值滤波（共享内存加速范式）</h3><p>适用于图像&#x2F;矩阵类任务（tile + halo）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cuda_runtime.h&gt;</span><br><span class="line"></span><br><span class="line">__global__ void mean3x3(const float* in, float* out, int H, int W) &#123;</span><br><span class="line">    // blockDim = (Bx, By)</span><br><span class="line">    const int x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    const int y = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    // tile 尺寸：块大小 + halo(上下左右各1)</span><br><span class="line">    const int Bx = blockDim.x;</span><br><span class="line">    const int By = blockDim.y;</span><br><span class="line">    extern __shared__ float tile[];</span><br><span class="line"></span><br><span class="line">    // tile 索引函数</span><br><span class="line">    auto t = [&amp;](int ty, int tx) -&gt; float&amp; &#123;</span><br><span class="line">        return tile[ty * (Bx + 2) + tx];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 对应 tile 坐标（+1 是为了留 halo）</span><br><span class="line">    const int tx = threadIdx.x + 1;</span><br><span class="line">    const int ty = threadIdx.y + 1;</span><br><span class="line"></span><br><span class="line">    // 读主区域</span><br><span class="line">    float v = 0.f;</span><br><span class="line">    if (x &lt; W &amp;&amp; y &lt; H) v = in[y * W + x];</span><br><span class="line">    t(ty, tx) = v;</span><br><span class="line"></span><br><span class="line">    // 读 halo（边界处做 clamp 或置零，这里用置零策略）</span><br><span class="line">    if (threadIdx.x == 0) &#123;</span><br><span class="line">        float lv = (x &gt; 0 &amp;&amp; y &lt; H) ? in[y * W + (x - 1)] : 0.f;</span><br><span class="line">        t(ty, 0) = lv;</span><br><span class="line">    &#125;</span><br><span class="line">    if (threadIdx.x == Bx - 1) &#123;</span><br><span class="line">        float rv = (x + 1 &lt; W &amp;&amp; y &lt; H) ? in[y * W + (x + 1)] : 0.f;</span><br><span class="line">        t(ty, Bx + 1) = rv;</span><br><span class="line">    &#125;</span><br><span class="line">    if (threadIdx.y == 0) &#123;</span><br><span class="line">        float uv = (y &gt; 0 &amp;&amp; x &lt; W) ? in[(y - 1) * W + x] : 0.f;</span><br><span class="line">        t(0, tx) = uv;</span><br><span class="line">    &#125;</span><br><span class="line">    if (threadIdx.y == By - 1) &#123;</span><br><span class="line">        float dv = (y + 1 &lt; H &amp;&amp; x &lt; W) ? in[(y + 1) * W + x] : 0.f;</span><br><span class="line">        t(By + 1, tx) = dv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 角落 halo（四个角）</span><br><span class="line">    if (threadIdx.x == 0 &amp;&amp; threadIdx.y == 0) &#123;</span><br><span class="line">        t(0,0) = (x&gt;0 &amp;&amp; y&gt;0) ? in[(y-1)*W + (x-1)] : 0.f;</span><br><span class="line">    &#125;</span><br><span class="line">    if (threadIdx.x == Bx-1 &amp;&amp; threadIdx.y == 0) &#123;</span><br><span class="line">        t(0,Bx+1) = (x+1&lt;W &amp;&amp; y&gt;0) ? in[(y-1)*W + (x+1)] : 0.f;</span><br><span class="line">    &#125;</span><br><span class="line">    if (threadIdx.x == 0 &amp;&amp; threadIdx.y == By-1) &#123;</span><br><span class="line">        t(By+1,0) = (x&gt;0 &amp;&amp; y+1&lt;H) ? in[(y+1)*W + (x-1)] : 0.f;</span><br><span class="line">    &#125;</span><br><span class="line">    if (threadIdx.x == Bx-1 &amp;&amp; threadIdx.y == By-1) &#123;</span><br><span class="line">        t(By+1,Bx+1) = (x+1&lt;W &amp;&amp; y+1&lt;H) ? in[(y+1)*W + (x+1)] : 0.f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __syncthreads();</span><br><span class="line"></span><br><span class="line">    if (x &lt; W &amp;&amp; y &lt; H) &#123;</span><br><span class="line">        float sum = 0.f;</span><br><span class="line">        sum += t(ty-1, tx-1); sum += t(ty-1, tx); sum += t(ty-1, tx+1);</span><br><span class="line">        sum += t(ty,   tx-1); sum += t(ty,   tx); sum += t(ty,   tx+1);</span><br><span class="line">        sum += t(ty+1, tx-1); sum += t(ty+1, tx); sum += t(ty+1, tx+1);</span><br><span class="line">        out[y * W + x] = sum / 9.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享内存大小（字节）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">((W + block.x - <span class="number">1</span>) / block.x, (H + block.y - <span class="number">1</span>) / block.y)</span></span>;</span><br><span class="line"><span class="type">size_t</span> shared_bytes = (block.x + <span class="number">2</span>) * (block.y + <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">float</span>);</span><br><span class="line">mean3x3&lt;&lt;&lt;grid, block, shared_bytes&gt;&gt;&gt;(in, out, H, W);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-CUDA-Streams-与异步拷贝"><a href="#10-CUDA-Streams-与异步拷贝" class="headerlink" title="10. CUDA Streams 与异步拷贝"></a>10. CUDA Streams 与异步拷贝</h2><h3 id="10-1-为什么需要-streams"><a href="#10-1-为什么需要-streams" class="headerlink" title="10.1 为什么需要 streams"></a>10.1 为什么需要 streams</h3><ul>
<li><p>默认 stream（stream 0）会形成较强的串行依赖</p>
</li>
<li><p>多 stream 可以实现：</p>
<ul>
<li>H2D 拷贝与 kernel 重叠</li>
<li>多批次流水线（pipeline）</li>
<li>与 <code>cudaMemcpyAsync</code> 配合提升吞吐</li>
</ul>
</li>
</ul>
<h3 id="10-2-pinned（页锁定）主机内存：提升异步拷贝效率"><a href="#10-2-pinned（页锁定）主机内存：提升异步拷贝效率" class="headerlink" title="10.2 pinned（页锁定）主机内存：提升异步拷贝效率"></a>10.2 pinned（页锁定）主机内存：提升异步拷贝效率</h3><ul>
<li><code>cudaMallocHost</code> &#x2F; <code>cudaFreeHost</code></li>
<li>pinned 内存更利于 DMA，<code>cudaMemcpyAsync</code> 才更有意义</li>
</ul>
<h3 id="10-3-基本模板：两条-stream-流水搬运"><a href="#10-3-基本模板：两条-stream-流水搬运" class="headerlink" title="10.3 基本模板：两条 stream 流水搬运"></a>10.3 基本模板：两条 stream 流水搬运</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cuda_runtime.h&gt;</span><br><span class="line"></span><br><span class="line">#define CUDA_CHECK(call) do &#123;                                  \</span><br><span class="line">  cudaError_t err = (call);                                    \</span><br><span class="line">  if (err != cudaSuccess) &#123;                                    \</span><br><span class="line">    std::fprintf(stderr, &quot;CUDA error %s:%d: %s\n&quot;,             \</span><br><span class="line">      __FILE__, __LINE__, cudaGetErrorString(err));            \</span><br><span class="line">    std::exit(1);                                              \</span><br><span class="line">  &#125;                                                            \</span><br><span class="line">&#125; while(0)</span><br><span class="line"></span><br><span class="line">__global__ void scale(float* x, int n, float a) &#123;</span><br><span class="line">    for (int i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">         i &lt; n; i += blockDim.x * gridDim.x) &#123;</span><br><span class="line">        x[i] *= a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const int n = 1 &lt;&lt; 20;</span><br><span class="line">    const size_t bytes = n * sizeof(float);</span><br><span class="line"></span><br><span class="line">    // pinned host memory</span><br><span class="line">    float* h = nullptr;</span><br><span class="line">    CUDA_CHECK(cudaMallocHost(&amp;h, bytes));</span><br><span class="line"></span><br><span class="line">    // device memory</span><br><span class="line">    float* d = nullptr;</span><br><span class="line">    CUDA_CHECK(cudaMalloc(&amp;d, bytes));</span><br><span class="line"></span><br><span class="line">    // init host</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) h[i] = 1.0f;</span><br><span class="line"></span><br><span class="line">    cudaStream_t s;</span><br><span class="line">    CUDA_CHECK(cudaStreamCreate(&amp;s));</span><br><span class="line"></span><br><span class="line">    // async H2D</span><br><span class="line">    CUDA_CHECK(cudaMemcpyAsync(d, h, bytes, cudaMemcpyHostToDevice, s));</span><br><span class="line"></span><br><span class="line">    // kernel in same stream (will wait for H2D in this stream)</span><br><span class="line">    scale&lt;&lt;&lt;256, 256, 0, s&gt;&gt;&gt;(d, n, 2.0f);</span><br><span class="line">    CUDA_CHECK(cudaGetLastError());</span><br><span class="line"></span><br><span class="line">    // async D2H</span><br><span class="line">    CUDA_CHECK(cudaMemcpyAsync(h, d, bytes, cudaMemcpyDeviceToHost, s));</span><br><span class="line"></span><br><span class="line">    // wait stream done</span><br><span class="line">    CUDA_CHECK(cudaStreamSynchronize(s));</span><br><span class="line"></span><br><span class="line">    std::printf(&quot;h[0]=%f, h[n-1]=%f\n&quot;, h[0], h[n-1]);</span><br><span class="line"></span><br><span class="line">    CUDA_CHECK(cudaStreamDestroy(s));</span><br><span class="line">    CUDA_CHECK(cudaFree(d));</span><br><span class="line">    CUDA_CHECK(cudaFreeHost(h));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4-事件计时（event-timing）"><a href="#10-4-事件计时（event-timing）" class="headerlink" title="10.4 事件计时（event timing）"></a>10.4 事件计时（event timing）</h3><p>用于测量 GPU 端耗时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cudaEvent_t st, ed;</span><br><span class="line"><span class="built_in">cudaEventCreate</span>(&amp;st); <span class="built_in">cudaEventCreate</span>(&amp;ed);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaEventRecord</span>(st, stream);</span><br><span class="line"><span class="comment">// kernel / memcpyAsync ...</span></span><br><span class="line"><span class="built_in">cudaEventRecord</span>(ed, stream);</span><br><span class="line"><span class="built_in">cudaEventSynchronize</span>(ed);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ms = <span class="number">0.f</span>;</span><br><span class="line"><span class="built_in">cudaEventElapsedTime</span>(&amp;ms, st, ed);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
        <category>高性能C++并行编程</category>
      </categories>
      <tags>
        <tag>并行编程</tag>
        <tag>CUDA</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title>c++进阶编程模版元编程</title>
    <url>/2025/12/16/%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%80%A7%E8%83%BDC++%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/c++%E8%BF%9B%E9%98%B6%E7%BC%96%E7%A8%8B%E6%A8%A1%E7%89%88%E5%85%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-进阶编程模版元编程"><a href="#C-进阶编程模版元编程" class="headerlink" title="C++进阶编程模版元编程"></a>C++进阶编程模版元编程</h1><p>time：2025_12_16</p>
<h2 id="模版函数定义"><a href="#模版函数定义" class="headerlink" title="模版函数定义"></a>模版函数定义</h2><p>模版函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">tiwice</span><span class="params">(T c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// std::string tiwice(std::string s) 自动重载</span></span><br><span class="line"><span class="comment">// 调用的时候要采用“tiwice(std::sting s)”不能直接使用tiwice(s) 这样会重载到tiwice&lt;char&gt;(s)的从而报错</span></span><br><span class="line"><span class="function">std::string <span class="title">tiwice</span><span class="params">(std::string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s+s</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="built_in">tiwice</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> <span class="number">2</span>)&lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    tiwice&lt;int&gt;(int 2) == tiwice(2)</span></span><br><span class="line"><span class="comment">    当模板类型参数 T 作为函数参数时，则可以省略该模板参数。自动根据调用者的参数判断。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::cout&lt;&lt; <span class="built_in">tiwice</span>&lt;<span class="type">float</span>&gt;(<span class="type">float</span> <span class="number">3.14</span>)&lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模版参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">templace &lt;<span class="type">int</span> N&gt; <span class="comment">//不过模板参数只支持整数类型（包括 enum）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_times</span><span class="params">(std::string msg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> i&lt;N;i++)&#123;</span><br><span class="line">        std::cout&lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">show_time</span>&lt;<span class="number">2</span>&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过模版常量定义编译常量优化代码运行速度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">templace &lt;<span class="type">bool</span> debug&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumto</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res +=i;</span><br><span class="line">        <span class="keyword">if</span>(debug) std::cout&lt;&lt; res&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="built_in">sumto</span>&lt;<span class="literal">false</span>&gt;(<span class="number">10</span>)&lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动推导类型（auto）"><a href="#自动推导类型（auto）" class="headerlink" title="自动推导类型（auto）"></a>自动推导类型（auto）</h2><p>&amp; 修饰符<br>const<br>int const 和 int 两个不同的常量<br>int &amp;&amp; -&gt; int const &amp;</p>
<h2 id="函数对象函数式编程"><a href="#函数对象函数式编程" class="headerlink" title="函数对象函数式编程"></a>函数对象函数式编程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_number</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number%d&quot;</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_float</span><span class="params">(<span class="type">float</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number%f&quot;</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Func</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_twice</span><span class="params">(Func func)</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">call_twice</span>(print_number)</span><br><span class="line">    <span class="built_in">call_twice</span>(print_float)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda <a href=""></a>{}<br>[&amp;] 闭包 可以引用main函数中的变量 读入写入 注意捕获对象的生命周期<br>[&#x3D;] 会给每一个引用了的变量做一份拷贝，放在 Func 类型中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Func</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_twice</span><span class="params">(Func <span class="type">const</span> &amp;func)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="built_in">func</span>(<span class="number">0</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout&lt;&lt; <span class="built_in">func</span>(<span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">make_tiwce</span><span class="params">(<span class="type">int</span> fac)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [=](<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">return</span> n*fac;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> twice = <span class="built_in">make_tiwce</span>(<span class="number">2</span>) <span class="comment">// fac = 2 return n*2;</span></span><br><span class="line">    <span class="built_in">call_twice</span>(twice);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda:yield model</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Func</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fetch_data</span><span class="params">(Func connst &amp;func)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">func</span>(i);</span><br><span class="line">        <span class="built_in">func</span>(i<span class="number">+0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; res_i;</span><br><span class="line">    std::vector&lt;<span class="type">float</span>&gt; res_f;</span><br><span class="line">    <span class="built_in">fetch_data</span>([&amp;](<span class="keyword">auto</span> <span class="type">const</span> &amp;x)&#123;</span><br><span class="line">        <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(x)&gt;;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T,<span class="type">int</span>&gt;)  res_i.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span>(std::is_same_v&lt;T,<span class="type">float</span>&gt;) res_f.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda 局部递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">4234</span>,<span class="number">21</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> <span class="type">const</span> &amp; dfs, <span class="type">int</span> index)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.<span class="built_in">find</span>(arr[index]) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">            visited.<span class="built_in">insert</span>(arr[index]);</span><br><span class="line">            <span class="type">int</span> next = arr[index];</span><br><span class="line">            <span class="built_in">dfs</span>(dfs, next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(dfs,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器tuple"><a href="#容器tuple" class="headerlink" title="容器tuple"></a>容器tuple</h2><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>运行常量和编译常量</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>高性能C++并行编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板元编程</tag>
      </tags>
  </entry>
  <entry>
    <title>vector容器优化编程</title>
    <url>/2025/11/22/%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%80%A7%E8%83%BDC++%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/vector%E5%AE%B9%E5%99%A8%E4%BC%98%E5%8C%96%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="vector-容器优化编程笔记"><a href="#vector-容器优化编程笔记" class="headerlink" title="vector 容器优化编程笔记"></a>vector 容器优化编程笔记</h1><p>时间：2025&#x2F;11&#x2F;22<br>课程地址：Bilibili – BV1qF411T7sd<br>课件仓库：parallel101&#x2F;course（GitHub）</p>
<hr>
<h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1-分配器（Allocator）"><a href="#1-分配器（Allocator）" class="headerlink" title="1. 分配器（Allocator）"></a>1. 分配器（Allocator）</h3><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>allocate(n)</code></td>
<td>分配 n 个 T 的原始内存（未构造对象）</td>
</tr>
<tr>
<td><code>deallocate(p, n)</code></td>
<td>释放之前分配的内存</td>
</tr>
<tr>
<td><code>construct(p, args...)</code></td>
<td>在 p 指向的位置调用 T 的构造函数</td>
</tr>
<tr>
<td><code>destroy(p)</code></td>
<td>调用 p 指向对象的析构函数</td>
</tr>
</tbody></table>
<p>vector 在扩容时会：</p>
<p>allocator.allocate() 申请更大内存</p>
<p>allocator.construct() 搬移原有元素</p>
<p>allocator.destroy() 销毁旧元素</p>
<p>allocator.deallocate() 释放旧内存</p>
<h3 id="2-迭代器（Iterator）"><a href="#2-迭代器（Iterator）" class="headerlink" title="2. 迭代器（Iterator）"></a>2. 迭代器（Iterator）</h3><p>提供一个统一的、类似指针的访问接口</p>
<p>迭代器 ≈ 指针的一般化版本</p>
<p>vector 的迭代器本质就是指针（随机访问）</p>
<p>list 的迭代器是包装了节点的对象（链式结构）</p>
<p>map&#x2F;set 的迭代器包装了树节点（红黑树结构）</p>
<p>所有迭代器都必须重载以下操作符：</p>
<p>*it 返回元素</p>
<p>it-&gt;member 访问结构体字段</p>
<p>++it &#x2F; –it 移动位置</p>
<p>it &#x3D;&#x3D; other 判断是否到达末尾</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>迭代器类型</th>
<th>是否连续内存</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>随机访问（指针）</td>
<td>是</td>
</tr>
<tr>
<td>array</td>
<td>随机访问（指针）</td>
<td>是</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问（复杂对象）</td>
<td>否</td>
</tr>
<tr>
<td>list</td>
<td>双向迭代器</td>
<td>否</td>
</tr>
<tr>
<td>set&#x2F;map</td>
<td>双向迭代器（红黑树）</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="3-仿函数（Functor）"><a href="#3-仿函数（Functor）" class="headerlink" title="3. 仿函数（Functor）"></a>3. 仿函数（Functor）</h3><p>仿函数也称“函数对象”（Function Object），本质是一个重载了 <code>operator()</code> 的类实例。<br>它既能像函数一样被调用，也能作为对象携带状态，因此常用于需要将“可调用对象”作为参数传入的场景中。</p>
<p>编写仿函数的基本方式：<br>创建一个类 → 实现内部逻辑 → 重载 <code>operator()</code>。<br>这样可以避免大量使用全局变量，同时便于逻辑复用，使代码更易维护和管理。</p>
<hr>
<h2 id="二、vector-容器"><a href="#二、vector-容器" class="headerlink" title="二、vector 容器"></a>二、vector 容器</h2><p><code>std::vector</code> 是一种动态数组，其元素存储在堆上，支持自动扩容。</p>
<p>常用操作说明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">4</span>)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>size()</strong><br><code>a.size()</code> 返回当前长度（元素个数）。</p>
</li>
<li><p><strong>operator[]</strong><br><code>a[x]</code> 等价于 <code>*(a.begin() + x)</code>。<br>需要注意：为了性能 <strong>不会做越界检查</strong>，越界可能导致未定义行为（包括程序崩溃）。</p>
</li>
<li><p><strong>at()</strong><br><code>a.at(x)</code> 与 <code>a[x]</code> 功能一致，但会进行边界检查（异常处理），可靠性更高但性能略低。</p>
</li>
<li><p><strong>resize(n)</strong><br>修改 vector 的逻辑长度为 n：</p>
<ul>
<li>n 变大：扩容位置填充默认值（int 为 0）</li>
<li>n 变小：截断，但多余空间不会立即释放，仅修改 size，不改 capacity</li>
</ul>
</li>
<li><p><strong>resize(n, val)</strong><br>扩容部分使用 <code>val</code> 填充。</p>
</li>
<li><p><strong>clear()</strong><br><code>a.clear()</code> 等价于 <code>a.resize(0)</code>；清空元素但不释放已分配内存。</p>
</li>
<li><p><strong>push_back(x)</strong><br>在末尾添加一个元素。<br>等价于：<code>a.resize(a.size()+1, x)</code>。</p>
</li>
<li><p><strong>pop_back()</strong><br>删除末尾元素（不返回值）。<br>等价于：<code>a.resize(a.size()-1)</code>。</p>
</li>
<li><p><strong>back()</strong><br>返回最后一个元素 <code>a[a.size()-1]</code>。</p>
</li>
<li><p><strong>front()</strong><br>等价于 <code>a[0]</code>。</p>
</li>
<li><p><strong>data()</strong><br>返回底层数组的首地址，即 <code>&amp;a[0]</code>。<br>通常需搭配 <code>size()</code> 使用，方便与 C 风格接口交互。<br><strong>注意：扩容后 data() 可能失效，因为底层地址可能改变。</strong></p>
</li>
<li><p><strong>capacity()</strong><br>返回当前实际分配的容量（不等于 size）。</p>
</li>
<li><p><strong>shrink_to_fit()</strong><br>请求释放多余内存，使 capacity 接近 size（但不保证一定有效）。</p>
</li>
</ol>
<hr>
<h2 id="三、迭代器"><a href="#三、迭代器" class="headerlink" title="三、迭代器"></a>三、迭代器</h2><p>迭代器本质上类似指针，但通过重载运算符实现对不同容器的统一访问方式。<br>可以理解为：<strong>“为容器设计的通用指针行为适配层”</strong>，从而兼容 C 语言的指针风格遍历。</p>
<hr>
<h2 id="四、补充知识"><a href="#四、补充知识" class="headerlink" title="四、补充知识"></a>四、补充知识</h2><h3 id="1-栈与堆"><a href="#1-栈与堆" class="headerlink" title="1. 栈与堆"></a>1. 栈与堆</h3><h4 id="Vector-对象本身的存储位置"><a href="#Vector-对象本身的存储位置" class="headerlink" title="Vector 对象本身的存储位置"></a>Vector <strong>对象本身</strong>的存储位置</h4><p>若直接作为局部变量声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br></pre></td></tr></table></figure>

<p><code>vec</code> 变量本身存储在 <strong>栈</strong> 上，包括：</p>
<ul>
<li>size</li>
<li>capacity</li>
<li>data 指针</li>
</ul>
<h4 id="Vector-元素的存储位置"><a href="#Vector-元素的存储位置" class="headerlink" title="Vector 元素的存储位置"></a>Vector <strong>元素</strong>的存储位置</h4><p>元素总是在 <strong>堆</strong> 上，因为 vector 需要支持动态扩容。</p>
<p>示意结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈内存</span><br><span class="line">    vector 对象本体</span><br><span class="line">    ├── size</span><br><span class="line">    ├── capacity</span><br><span class="line">    └── data 指针（指向堆）</span><br><span class="line"></span><br><span class="line">堆内存</span><br><span class="line">    元素1</span><br><span class="line">    元素2</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><ol>
<li><p><em>仿函数详解</em><br><a href="https://www.cnblogs.com/helloylh/p/17209709.html">https://www.cnblogs.com/helloylh/p/17209709.html</a></p>
</li>
<li><p><em>Vector 对象到底在堆上还是栈上？</em><br><a href="https://www.51cto.com/article/814126.html">https://www.51cto.com/article/814126.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>高性能C++并行编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>性能优化</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11开始的多线程编程</title>
    <url>/2025/12/19/%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%80%A7%E8%83%BDC++%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/c++11%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="C-11-起的多线程编程笔记"><a href="#C-11-起的多线程编程笔记" class="headerlink" title="C++11 起的多线程编程笔记"></a>C++11 起的多线程编程笔记</h1><blockquote>
<p>C++11 标准库并发组件：<code>&lt;thread&gt; / &lt;mutex&gt; / &lt;condition_variable&gt; / &lt;future&gt; / &lt;atomic&gt; / &lt;chrono&gt;</code><br>目标：并发执行（性能） + 正确同步（安全） + 生命周期可控（可维护）。</p>
</blockquote>
<h2 id="1-时间与计时-std-chrono"><a href="#1-时间与计时-std-chrono" class="headerlink" title="1. 时间与计时 std::chrono"></a>1. 时间与计时 <code>std::chrono</code></h2><h3 id="1-1-三个核心类型"><a href="#1-1-三个核心类型" class="headerlink" title="1.1 三个核心类型"></a>1.1 三个核心类型</h3><ul>
<li><code>clock</code>：时钟（如 <code>steady_clock</code>、<code>system_clock</code>）</li>
<li><code>time_point</code>：时间点（<code>clock::time_point</code>）</li>
<li><code>duration</code>：时长（<code>seconds/milliseconds/...</code>）</li>
</ul>
<h3 id="1-2-计时：推荐-steady-clock（不会被系统调时影响）"><a href="#1-2-计时：推荐-steady-clock（不会被系统调时影响）" class="headerlink" title="1.2 计时：推荐 steady_clock（不会被系统调时影响）"></a>1.2 计时：推荐 <code>steady_clock</code>（不会被系统调时影响）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t0 = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> t1 = t0 + std::chrono::<span class="built_in">seconds</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dt = t1 - t0; <span class="comment">// duration</span></span><br><span class="line">    std::<span class="type">int64_t</span> sec = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(dt).<span class="built_in">count</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;dt = &quot;</span> &lt;&lt; sec &lt;&lt; <span class="string">&quot; s\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-常见时间单位"><a href="#1-3-常见时间单位" class="headerlink" title="1.3 常见时间单位"></a>1.3 常见时间单位</h3><ul>
<li><code>std::chrono::seconds(x)</code></li>
<li><code>std::chrono::milliseconds(x)</code></li>
<li><code>std::chrono::microseconds(x)</code></li>
<li><code>std::chrono::nanoseconds(x)</code></li>
</ul>
<h3 id="1-4-测耗时并转-double-毫秒"><a href="#1-4-测耗时并转-double-毫秒" class="headerlink" title="1.4 测耗时并转 double 毫秒"></a>1.4 测耗时并转 double 毫秒</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t0 = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    std::<span class="type">uint64_t</span> acc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1&#x27;000&#x27;000</span>; ++i) acc += i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t1 = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">using</span> double_ms = std::chrono::duration&lt;<span class="type">double</span>, std::milli&gt;;</span><br><span class="line">    <span class="type">double</span> ms = std::chrono::<span class="built_in">duration_cast</span>&lt;double_ms&gt;(t1 - t0).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;cost = &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms, acc=&quot;</span> &lt;&lt; acc &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-线程休眠：避免忙等"><a href="#2-线程休眠：避免忙等" class="headerlink" title="2. 线程休眠：避免忙等"></a>2. 线程休眠：避免忙等</h2><h3 id="2-1-sleep-for"><a href="#2-1-sleep-for" class="headerlink" title="2.1 sleep_for"></a>2.1 <code>sleep_for</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">400</span>));</span><br></pre></td></tr></table></figure>

<h3 id="2-2-sleep-until（对齐节拍更合适）"><a href="#2-2-sleep-until（对齐节拍更合适）" class="headerlink" title="2.2 sleep_until（对齐节拍更合适）"></a>2.2 <code>sleep_until</code>（对齐节拍更合适）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> t = std::chrono::steady_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">milliseconds</span>(<span class="number">400</span>);</span><br><span class="line">std::this_thread::<span class="built_in">sleep_until</span>(t);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-实例：固定频率循环（推荐写法）"><a href="#2-3-实例：固定频率循环（推荐写法）" class="headerlink" title="2.3 实例：固定频率循环（推荐写法）"></a>2.3 实例：固定频率循环（推荐写法）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> clock = std::chrono::steady_clock;</span><br><span class="line">    <span class="keyword">auto</span> next = clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        next += std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tick &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_until</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-基础线程-std-thread"><a href="#3-基础线程-std-thread" class="headerlink" title="3. 基础线程 std::thread"></a>3. 基础线程 <code>std::thread</code></h2><h3 id="3-1-启动线程与-join（必须）"><a href="#3-1-启动线程与-join（必须）" class="headerlink" title="3.1 启动线程与 join（必须）"></a>3.1 启动线程与 join（必须）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(work, <span class="number">1</span>)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 必须 join 或 detach，否则析构会 std::terminate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>join()</code>：等待线程结束（最常用）</li>
<li><code>detach()</code>：放飞线程（风险高：对象生命周期&#x2F;退出时机难控）</li>
</ul>
<hr>
<h2 id="4-异步与返回值：std-async-std-future"><a href="#4-异步与返回值：std-async-std-future" class="headerlink" title="4. 异步与返回值：std::async &#x2F; std::future"></a>4. 异步与返回值：<code>std::async</code> &#x2F; <code>std::future</code></h2><h3 id="4-1-基本用法（带返回值）"><a href="#4-1-基本用法（带返回值）" class="headerlink" title="4.1 基本用法（带返回值）"></a>4.1 基本用法（带返回值）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">download</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">404</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(std::launch::async, [] &#123; <span class="keyword">return</span> <span class="built_in">download</span>(); &#125;);</span><br><span class="line">    <span class="type">int</span> ret = fut.<span class="built_in">get</span>(); <span class="comment">// get 只能调用一次</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-启动策略"><a href="#4-2-启动策略" class="headerlink" title="4.2 启动策略"></a>4.2 启动策略</h3><ul>
<li><code>std::launch::async</code>：倾向于并行执行</li>
<li><code>std::launch::deferred</code>：延迟到 <code>get()/wait()</code> 才在当前线程执行</li>
</ul>
<h3 id="4-3-wait-wait-for-wait-until"><a href="#4-3-wait-wait-for-wait-until" class="headerlink" title="4.3 wait &#x2F; wait_for &#x2F; wait_until"></a>4.3 wait &#x2F; wait_for &#x2F; wait_until</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(std::launch::async, []&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fut.<span class="built_in">wait</span>(); <span class="comment">// 等到完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> st = fut.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line"><span class="keyword">if</span> (st == std::future_status::timeout) &#123;</span><br><span class="line">    <span class="comment">// 还没完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-异常会在-get-处重抛（非常实用）"><a href="#4-4-异常会在-get-处重抛（非常实用）" class="headerlink" title="4.4 异常会在 get() 处重抛（非常实用）"></a>4.4 异常会在 get() 处重抛（非常实用）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fut = std::<span class="built_in">async</span>(std::launch::async, []() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;boom&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123; fut.<span class="built_in">get</span>(); &#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123; std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-互斥锁-std-mutex：保护共享数据"><a href="#5-互斥锁-std-mutex：保护共享数据" class="headerlink" title="5. 互斥锁 std::mutex：保护共享数据"></a>5. 互斥锁 <code>std::mutex</code>：保护共享数据</h2><h3 id="5-1-lock-guard（RAII-自动解锁）"><a href="#5-1-lock-guard（RAII-自动解锁）" class="headerlink" title="5.1 lock_guard（RAII 自动解锁）"></a>5.1 <code>lock_guard</code>（RAII 自动解锁）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> inc = [&amp;] &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">            ++counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(inc)</span>, <span class="title">t2</span><span class="params">(inc)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;counter=&quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-死锁规避（两个锁）"><a href="#5-2-死锁规避（两个锁）" class="headerlink" title="5.2 死锁规避（两个锁）"></a>5.2 死锁规避（两个锁）</h3><p>C++11 可用 <code>std::lock</code> + <code>std::adopt_lock</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex m1, m2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">lock</span>(m1, m2);</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk1</span><span class="params">(m1, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk2</span><span class="params">(m2, std::adopt_lock)</span></span>;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-条件变量-std-condition-variable：生产者-消费者（比-sleep-正确）"><a href="#6-条件变量-std-condition-variable：生产者-消费者（比-sleep-正确）" class="headerlink" title="6. 条件变量 std::condition_variable：生产者-消费者（比 sleep 正确）"></a>6. 条件变量 <code>std::condition_variable</code>：生产者-消费者（比 sleep 正确）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">([&amp;]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#123; std::lock_guard&lt;std::mutex&gt; lk(m); q.push(i); &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            cv.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#123; std::lock_guard&lt;std::mutex&gt; lk(m); done = <span class="literal">true</span>; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        cv.notify_one();</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">consumer</span><span class="params">([&amp;]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::unique_lock&lt;std::mutex&gt; lk(m);</span></span></span><br><span class="line"><span class="params"><span class="function">            cv.wait(lk, [&amp;]&#123; <span class="keyword">return</span> done || !q.empty(); &#125;); <span class="comment">// 带谓词防虚假唤醒</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">while</span> (!q.empty()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                std::cout &lt;&lt; <span class="string">&quot;consume &quot;</span> &lt;&lt; q.front() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                q.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (done) <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-原子-std-atomic：轻量同步（计数-标志位）"><a href="#7-原子-std-atomic：轻量同步（计数-标志位）" class="headerlink" title="7. 原子 std::atomic：轻量同步（计数&#x2F;标志位）"></a>7. 原子 <code>std::atomic</code>：轻量同步（计数&#x2F;标志位）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; counter&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> inc = [&amp;] &#123; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) ++counter; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(inc)</span>, <span class="title">t2</span><span class="params">(inc)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>(); t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;counter=&quot;</span> &lt;&lt; counter.<span class="built_in">load</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-线程池-任务队列（C-11-可直接用）"><a href="#8-线程池-任务队列（C-11-可直接用）" class="headerlink" title="8. 线程池&#x2F;任务队列（C++11 可直接用）"></a>8. 线程池&#x2F;任务队列（C++11 可直接用）</h2><blockquote>
<p>线程池 &#x3D; 固定 worker 线程 + 任务队列（阻塞队列）<br>典型价值：避免频繁创建&#x2F;销毁线程，提高吞吐；统一任务提交接口，支持 <code>future</code> 返回值与异常回传。</p>
</blockquote>
<h3 id="8-1-任务队列：BlockingQueue（阻塞队列）"><a href="#8-1-任务队列：BlockingQueue（阻塞队列）" class="headerlink" title="8.1 任务队列：BlockingQueue（阻塞队列）"></a>8.1 任务队列：BlockingQueue（阻塞队列）</h3><p>特性：</p>
<ul>
<li><code>push()</code> 入队并唤醒消费者</li>
<li><code>pop()</code> 阻塞等待任务；队列关闭且为空时返回 <code>false</code></li>
<li><code>close()</code> 关闭队列并唤醒全部等待线程</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlockingQueue</span>() : <span class="built_in">closed_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BlockingQueue</span>(<span class="type">const</span> BlockingQueue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    BlockingQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> BlockingQueue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (closed_) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q_.<span class="built_in">push</span>(std::<span class="built_in">move</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line">        cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; out)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_)</span></span>;</span><br><span class="line">        cv_.<span class="built_in">wait</span>(lk, [&amp;]&#123; <span class="keyword">return</span> closed_ || !q_.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q_.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// closed_ &amp;&amp; empty</span></span><br><span class="line">        out = std::<span class="built_in">move</span>(q_.<span class="built_in">front</span>());</span><br><span class="line">        q_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m_)</span></span>;</span><br><span class="line">            closed_ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cv_.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex m_;</span><br><span class="line">    std::condition_variable cv_;</span><br><span class="line">    std::queue&lt;T&gt; q_;</span><br><span class="line">    <span class="type">bool</span> closed_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-线程池：ThreadPool（enqueue-返回-future）"><a href="#8-2-线程池：ThreadPool（enqueue-返回-future）" class="headerlink" title="8.2 线程池：ThreadPool（enqueue 返回 future）"></a>8.2 线程池：ThreadPool（enqueue 返回 future）</h3><p>特性：</p>
<ul>
<li>固定线程数 worker</li>
<li><code>enqueue(f, args...)</code> 返回 <code>std::future&lt;R&gt;</code></li>
<li>任务抛异常 → 在 <code>future.get()</code> 时重抛</li>
<li>析构&#x2F;<code>shutdown()</code>：停止接收新任务 + 关闭队列 + <code>join</code> 所有 worker</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;blocking_queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="type">size_t</span> nthreads)</span> : accept_(true) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (nthreads == <span class="number">0</span>) nthreads = <span class="number">1</span>;</span><br><span class="line">        workers_.<span class="built_in">reserve</span>(nthreads);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nthreads; ++i) &#123;</span><br><span class="line">            workers_.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>([<span class="keyword">this</span>]&#123; <span class="built_in">worker_loop</span>(); &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ThreadPool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ThreadPool</span>() &#123; <span class="built_in">shutdown</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">        -&gt; std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type R;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!accept_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;ThreadPool is not accepting new tasks.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">R</span>()&gt;&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        );</span><br><span class="line">        std::future&lt;R&gt; fut = task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> ok = tasks_.<span class="built_in">push</span>([task_ptr]&#123; (*task_ptr)(); &#125;);</span><br><span class="line">        <span class="keyword">if</span> (!ok) <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Task queue is closed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fut;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> expected = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (accept_.<span class="built_in">compare_exchange_strong</span>(expected, <span class="literal">false</span>)) &#123;</span><br><span class="line">            tasks_.<span class="built_in">close</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : workers_) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) t.<span class="built_in">join</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">worker_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">        <span class="keyword">while</span> (tasks_.<span class="built_in">pop</span>(task)) &#123;</span><br><span class="line">            <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; workers_;</span><br><span class="line">    BlockingQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks_;</span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; accept_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-线程池使用示例（返回值-异常回传）"><a href="#8-3-线程池使用示例（返回值-异常回传）" class="headerlink" title="8.3 线程池使用示例（返回值 + 异常回传）"></a>8.3 线程池使用示例（返回值 + 异常回传）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread_pool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">slow_add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f1 = pool.<span class="built_in">enqueue</span>(slow_add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> f2 = pool.<span class="built_in">enqueue</span>([](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x * x; &#125;, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f3 = pool.<span class="built_in">enqueue</span>([]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;boom&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f1=&quot;</span> &lt;&lt; f<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f2=&quot;</span> &lt;&lt; f<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;f3=&quot;</span> &lt;&lt; f<span class="number">3.</span><span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool.<span class="built_in">shutdown</span>(); <span class="comment">// 可省略：析构也会 shutdown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>高性能C++并行编程</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>从汇编角度看编译器优化</title>
    <url>/2025/12/17/%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%80%A7%E8%83%BDC++%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/%E4%BB%8E%E6%B1%87%E7%BC%96%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="从汇编角度看编译器优化【暂时搁浅跳过】"><a href="#从汇编角度看编译器优化【暂时搁浅跳过】" class="headerlink" title="从汇编角度看编译器优化【暂时搁浅跳过】"></a>从汇编角度看编译器优化【暂时搁浅跳过】</h1><p>time:2025_12_17<br>主要讨论了不同系统下编译器的优化差异所带来的不同问题，以及针对不同问题的进行优化和修复</p>
<p>指针的索引尽量采用size_t 防止出现负值出现数组越界的情况<br>x64 size_t &#x3D; uint64_t<br>x32 size_t &#x3D; uint32_t</p>
<p>constexpr 在调用前就进行编译 强迫编译器在编译期求值<br>const 只有在调用到后才进行编译</p>
<p>static 局部可见函数</p>
<p>AOS（Array of Struct）单个对象的属性紧挨着存<br>SOA（Struct of Array）属性分离存储在多个数组</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>高性能C++并行编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编译优化</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>从计算机原理探讨C指针</title>
    <url>/2025/12/17/%E5%AD%A6%E4%B9%A0/%E9%AB%98%E6%80%A7%E8%83%BDC++%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/%E4%BB%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E6%8E%A2%E8%AE%A8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="从计算机原理探讨C指针"><a href="#从计算机原理探讨C指针" class="headerlink" title="从计算机原理探讨C指针"></a>从计算机原理探讨C指针</h1>]]></content>
      <categories>
        <category>学习</category>
        <category>高性能C++并行编程</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>指针</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>实现untptr</title>
    <url>/2026/01/16/%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E8%B7%B5/%5B1%5D%E5%AE%9E%E7%8E%B0untptr/</url>
    <content><![CDATA[<h1 id="实现untptr"><a href="#实现untptr" class="headerlink" title="实现untptr"></a>实现untptr</h1><p>下面把我们这几轮对话内容整理成一份可直接作为“C++ 构造&#x2F;析构&#x2F;拷贝&#x2F;移动”学习笔记的版本，并专门加入 <code>std::move</code> 的机制解析与常见误区澄清（结合你写的 <code>UniquePtr</code> 语义）。</p>
<hr>
<h1 id="C-对象生命周期与特殊成员函数笔记（构造-析构-拷贝-移动-std-move）"><a href="#C-对象生命周期与特殊成员函数笔记（构造-析构-拷贝-移动-std-move）" class="headerlink" title="C++ 对象生命周期与特殊成员函数笔记（构造 &#x2F; 析构 &#x2F; 拷贝 &#x2F; 移动 + std::move）"></a>C++ 对象生命周期与特殊成员函数笔记（构造 &#x2F; 析构 &#x2F; 拷贝 &#x2F; 移动 + std::move）</h1><h2 id="1-对象生命周期与-RAII"><a href="#1-对象生命周期与-RAII" class="headerlink" title="1. 对象生命周期与 RAII"></a>1. 对象生命周期与 RAII</h2><h3 id="1-1-生命周期顺序"><a href="#1-1-生命周期顺序" class="headerlink" title="1.1 生命周期顺序"></a>1.1 生命周期顺序</h3><p>对象的一生通常经历：</p>
<ol>
<li><strong>构造（constructor）</strong>：把对象初始化到“可用且满足类不变量”的状态</li>
<li><strong>使用（member functions）</strong></li>
<li><strong>析构（destructor）</strong>：对象生命周期结束时清理资源</li>
</ol>
<blockquote>
<p>局部对象在<strong>作用域结束</strong>时析构（最常见是离开 <code>&#123;&#125;</code> 块）。<br>动态对象（<code>new</code>）在 <code>delete</code> 时析构；由智能指针管理则在智能指针析构时触发 <code>delete</code>。</p>
</blockquote>
<h3 id="1-2-RAII-核心"><a href="#1-2-RAII-核心" class="headerlink" title="1.2 RAII 核心"></a>1.2 RAII 核心</h3><p><strong>资源获取在构造，资源释放在析构</strong>。<br>智能指针&#x2F;资源管理类的价值：把“释放资源”绑定到对象生命周期上，避免泄漏。</p>
<hr>
<h2 id="2-六大特殊成员函数（Special-Member-Functions）"><a href="#2-六大特殊成员函数（Special-Member-Functions）" class="headerlink" title="2. 六大特殊成员函数（Special Member Functions）"></a>2. 六大特殊成员函数（Special Member Functions）</h2><p>一个类最关键的 6 个函数：</p>
<ol>
<li>默认构造 <code>T()</code></li>
<li>析构 <code>~T()</code></li>
<li>拷贝构造 <code>T(const T&amp;)</code></li>
<li>拷贝赋值 <code>T&amp; operator=(const T&amp;)</code></li>
<li>移动构造 <code>T(T&amp;&amp;)</code></li>
<li>移动赋值 <code>T&amp; operator=(T&amp;&amp;)</code></li>
</ol>
<p>它们决定：对象如何创建、复制、转移、销毁。</p>
<hr>
<h2 id="3-拷贝构造-vs-拷贝赋值：区别与触发场景"><a href="#3-拷贝构造-vs-拷贝赋值：区别与触发场景" class="headerlink" title="3. 拷贝构造 vs 拷贝赋值：区别与触发场景"></a>3. 拷贝构造 vs 拷贝赋值：区别与触发场景</h2><h3 id="3-1-拷贝构造（copy-constructor）"><a href="#3-1-拷贝构造（copy-constructor）" class="headerlink" title="3.1 拷贝构造（copy constructor）"></a>3.1 拷贝构造（copy constructor）</h3><p><strong>用一个对象去初始化另一个“新对象”</strong>。目标对象此时尚未构造完成。</p>
<p>触发示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">b</span><span class="params">(a)</span></span>;        <span class="comment">// 直接初始化</span></span><br><span class="line">T b = a;       <span class="comment">// 语法像赋值，但本质仍是拷贝构造（拷贝初始化）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T x)</span></span>;   <span class="comment">// 传值形参：用实参构造形参（可能被优化/移动）</span></span><br><span class="line"><span class="keyword">return</span> x;      <span class="comment">// 按值返回：可能触发拷贝构造（或移动/NRVO）</span></span><br></pre></td></tr></table></figure>

<p>函数签名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(<span class="type">const</span> T&amp; other);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-拷贝赋值（copy-assignment）"><a href="#3-2-拷贝赋值（copy-assignment）" class="headerlink" title="3.2 拷贝赋值（copy assignment）"></a>3.2 拷贝赋值（copy assignment）</h3><p><strong>把一个已有对象覆盖成另一个对象的状态</strong>。目标对象已经构造完成，可能还持有资源。</p>
<p>触发示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T b;</span><br><span class="line">b = a;         <span class="comment">// 拷贝赋值：b 已存在，被覆盖</span></span><br></pre></td></tr></table></figure>

<p>函数签名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>=(<span class="type">const</span> T&amp; other);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-关键差异总结"><a href="#3-3-关键差异总结" class="headerlink" title="3.3 关键差异总结"></a>3.3 关键差异总结</h3><ul>
<li>拷贝构造：目标对象“从无到有”，主要是初始化</li>
<li>拷贝赋值：目标对象“已存在”，必须处理旧资源、自赋值、异常安全</li>
</ul>
<hr>
<h2 id="4-移动语义：移动构造-移动赋值的核心"><a href="#4-移动语义：移动构造-移动赋值的核心" class="headerlink" title="4. 移动语义：移动构造&#x2F;移动赋值的核心"></a>4. 移动语义：移动构造&#x2F;移动赋值的核心</h2><h3 id="4-1-移动（move）的语义"><a href="#4-1-移动（move）的语义" class="headerlink" title="4.1 移动（move）的语义"></a>4.1 移动（move）的语义</h3><p><strong>转移资源所有权</strong>（或资源句柄），而不是复制。移动后源对象进入“可析构、可赋值，但资源被移走”的有效状态（通常置空）。</p>
<p>移动构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(T&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>

<p>移动赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T&amp; <span class="keyword">operator</span>=(T&amp;&amp; other) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-移动赋值的关键步骤"><a href="#4-2-移动赋值的关键步骤" class="headerlink" title="4.2 移动赋值的关键步骤"></a>4.2 移动赋值的关键步骤</h3><p>移动赋值比移动构造更复杂，因为左侧对象已有资源：</p>
<p>典型模式：</p>
<ol>
<li><code>if (this != &amp;other)</code> 自移动保护</li>
<li>释放当前资源（防泄漏）</li>
<li>接管对方资源</li>
<li>把对方置为空状态</li>
</ol>
<hr>
<h2 id="5-std-move-解析（重点）"><a href="#5-std-move-解析（重点）" class="headerlink" title="5. std::move 解析（重点）"></a>5. std::move 解析（重点）</h2><h3 id="5-1-std-move-的本质"><a href="#5-1-std-move-的本质" class="headerlink" title="5.1 std::move 的本质"></a>5.1 <code>std::move</code> 的本质</h3><p><code>std::move(x)</code> <strong>不移动任何东西</strong>。它只是一个<strong>类型转换</strong>：</p>
<ul>
<li>把 <code>x</code> 从左值转换为右值引用（<code>T&amp;&amp;</code>）</li>
<li>让重载解析“更倾向”选择移动构造&#x2F;移动赋值</li>
</ul>
<p>可以把它理解为：<strong>“允许被偷资源”</strong> 的标记。</p>
<h3 id="5-2-发生移动的条件"><a href="#5-2-发生移动的条件" class="headerlink" title="5.2 发生移动的条件"></a>5.2 发生移动的条件</h3><p>发生移动的前提是：类型真的提供了可用的移动操作（或编译器生成了它）。</p>
<ul>
<li>如果移动构造&#x2F;移动赋值存在：<code>std::move(x)</code> 会触发移动路径</li>
<li>如果移动被 <code>= delete</code> 禁掉：<code>std::move(x)</code> 要么导致编译错误，要么退化为拷贝（如果拷贝可用且可匹配）</li>
</ul>
<h3 id="5-3-“禁止移动还能用-move-转移所有权吗？”"><a href="#5-3-“禁止移动还能用-move-转移所有权吗？”" class="headerlink" title="5.3 “禁止移动还能用 move 转移所有权吗？”"></a>5.3 “禁止移动还能用 move 转移所有权吗？”</h3><p>不能。因为 <code>std::move</code> 只是转型，<strong>没有可用移动函数就无法发生“转移所有权”</strong>。</p>
<p>对“唯一所有权类（unique ownership）”来说：</p>
<ul>
<li>允许拷贝会破坏唯一性（两个对象指向同一资源 → double free）</li>
<li>禁用拷贝是必须的</li>
<li>若再禁用移动，则类型变成“不可转移的唯一所有权”，能保证唯一性，但几乎无法在函数间转交所有权，工程可用性很差</li>
</ul>
<p><strong>结论：</strong></p>
<ul>
<li><code>UniquePtr</code> 这类唯一所有权类型：<strong>禁拷贝 + 允移动</strong> 是主流设计</li>
<li><code>std::move</code> 不能绕过你对移动&#x2F;拷贝的限制</li>
</ul>
<hr>
<h2 id="6-Rule-of-0-3-5：什么时候需要写这些函数"><a href="#6-Rule-of-0-3-5：什么时候需要写这些函数" class="headerlink" title="6. Rule of 0 &#x2F; 3 &#x2F; 5：什么时候需要写这些函数"></a>6. Rule of 0 &#x2F; 3 &#x2F; 5：什么时候需要写这些函数</h2><ul>
<li><strong>Rule of 0</strong>：类不直接管理资源（只用 STL&#x2F;智能指针成员） → 尽量不写特殊成员函数</li>
<li><strong>Rule of 5</strong>：类直接管理资源（裸指针&#x2F;句柄） → 通常要系统处理析构、拷贝、移动（以及赋值）</li>
</ul>
<p>你的 <code>UniquePtr</code> 属于典型 Rule of 5：管理裸指针资源，必须手写&#x2F;控制这些语义。</p>
<hr>
<h2 id="7-示例：MyString（手写资源管理类）展示拷贝与移动"><a href="#7-示例：MyString（手写资源管理类）展示拷贝与移动" class="headerlink" title="7. 示例：MyString（手写资源管理类）展示拷贝与移动"></a>7. 示例：<code>MyString</code>（手写资源管理类）展示拷贝与移动</h2><p>目标：拥有一段堆内存 char buffer。</p>
<ul>
<li>拷贝：深拷贝（各自拥有各自 buffer）</li>
<li>移动：偷指针（转移 buffer 所有权，源对象置空）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>() <span class="keyword">noexcept</span> : <span class="built_in">ptr_</span>(<span class="literal">nullptr</span>), <span class="built_in">len_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s) &#123; ptr_ = <span class="literal">nullptr</span>; len_ = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">        len_ = std::<span class="built_in">strlen</span>(s);</span><br><span class="line">        ptr_ = <span class="keyword">new</span> <span class="type">char</span>[len_ + <span class="number">1</span>];</span><br><span class="line">        std::<span class="built_in">memcpy</span>(ptr_, s, len_ + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyString</span>() <span class="keyword">noexcept</span> &#123; <span class="keyword">delete</span>[] ptr_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造：深拷贝</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        len_ = other.len_;</span><br><span class="line">        <span class="keyword">if</span> (len_ == <span class="number">0</span>) &#123; ptr_ = <span class="literal">nullptr</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">        ptr_ = <span class="keyword">new</span> <span class="type">char</span>[len_ + <span class="number">1</span>];</span><br><span class="line">        std::<span class="built_in">memcpy</span>(ptr_, other.ptr_, len_ + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造：偷资源</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">ptr_</span>(std::<span class="built_in">exchange</span>(other.ptr_, <span class="literal">nullptr</span>)),</span><br><span class="line">          <span class="built_in">len_</span>(std::<span class="built_in">exchange</span>(other.len_, <span class="number">0</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(MyString&amp; rhs)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">        std::<span class="built_in">swap</span>(len_, rhs.len_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值：copy-and-swap（强异常安全）</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        MyString <span class="built_in">tmp</span>(other); <span class="comment">// 可能抛异常，但不影响 *this</span></span><br><span class="line">        tmp.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值：释放旧资源 + 偷新资源</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] ptr_;</span><br><span class="line">            ptr_ = std::<span class="built_in">exchange</span>(other.ptr_, <span class="literal">nullptr</span>);</span><br><span class="line">            len_ = std::<span class="built_in">exchange</span>(other.len_, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* ptr_;</span><br><span class="line">    std::<span class="type">size_t</span> len_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DefaultDeleter</span> &#123; <span class="comment">// 默认使用 delete 释放内存</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp *p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DefaultDeleter</span>&lt;_Tp[]&gt; &#123; <span class="comment">// 偏特化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp *p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Deleter</span> = DefaultDeleter&lt;_Tp&gt;&gt;</span><br><span class="line"><span class="keyword">struct</span> UniquePtr &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Tp *_M_p;</span><br><span class="line">    [[no_unique_address]] _Deleter _M_deleter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="keyword">class</span> <span class="title class_">_UDeleter</span>&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">struct</span> <span class="title class_">UniquePtr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> element_type = _Tp;</span><br><span class="line">    <span class="keyword">using</span> pointer = _Tp *;</span><br><span class="line">    <span class="keyword">using</span> deleter_type = _Deleter;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UniquePtr</span>(std::<span class="type">nullptr_t</span> = <span class="literal">nullptr</span>) <span class="keyword">noexcept</span> : _M_p(<span class="literal">nullptr</span>) &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">UniquePtr</span><span class="params">(_Tp *p)</span> <span class="keyword">noexcept</span> : _M_p(p) &#123;</span> <span class="comment">// 自定义构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="keyword">class</span> <span class="title class_">_UDeleter</span>, <span class="keyword">class</span> = std::<span class="type">enable_if_t</span>&lt;std::is_convertible_v&lt;_Up *, _Tp *&gt;&gt;&gt; <span class="comment">// 没有 C++20 的写法</span></span><br><span class="line">    <span class="comment">// template &lt;class _Up, class _UDeleter&gt; requires (std::convertible_to&lt;_Up *, _Tp *&gt;) // 有 C++20 的写法</span></span><br><span class="line">    <span class="built_in">UniquePtr</span>(UniquePtr&lt;_Up, _UDeleter&gt; &amp;&amp;__that) <span class="keyword">noexcept</span> : _M_p(__that._M_p) &#123;  <span class="comment">// 从子类型_Up的智能指针转换到_Tp类型的智能指针</span></span><br><span class="line">        __that._M_p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UniquePtr</span>() <span class="keyword">noexcept</span> &#123; <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="keyword">if</span> (_M_p)</span><br><span class="line">            _M_deleter(_M_p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UniquePtr</span>(UniquePtr <span class="type">const</span> &amp;__that) = <span class="keyword">delete</span>; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    UniquePtr &amp;<span class="keyword">operator</span>=(UniquePtr <span class="type">const</span> &amp;__that) = <span class="keyword">delete</span>; <span class="comment">// 拷贝赋值函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UniquePtr</span>(UniquePtr &amp;&amp;__that) <span class="keyword">noexcept</span> : _M_p(__that._M_p) &#123; <span class="comment">// 移动构造函数</span></span><br><span class="line">        __that._M_p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UniquePtr &amp;<span class="keyword">operator</span>=(UniquePtr &amp;&amp;__that) <span class="keyword">noexcept</span> &#123; <span class="comment">// 移动赋值函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;__that) [[likely]] &#123;</span><br><span class="line">            <span class="keyword">if</span> (_M_p)</span><br><span class="line">                _M_deleter(_M_p);</span><br><span class="line">            _M_p = std::<span class="built_in">exchange</span>(__that._M_p, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(UniquePtr &amp;__that)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// 交换函数</span></span><br><span class="line">        std::<span class="built_in">swap</span>(_M_p, __that._M_p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_Tp *<span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Tp *<span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _M_p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="type">add_lvalue_reference_t</span>&lt;_Tp&gt; <span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *_M_p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_Deleter <span class="title">get_deleter</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_deleter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_Tp *<span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        _Tp *__p = _M_p;</span><br><span class="line">        _M_p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> __p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(_Tp *__p = <span class="literal">nullptr</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_M_p)</span><br><span class="line">            _M_deleter(_M_p);</span><br><span class="line">        _M_p = __p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _M_p != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(UniquePtr <span class="type">const</span> &amp;__that) <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _M_p == __that._M_p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(UniquePtr <span class="type">const</span> &amp;__that) <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _M_p != __that._M_p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(UniquePtr <span class="type">const</span> &amp;__that) <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _M_p &lt; __that._M_p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(UniquePtr <span class="type">const</span> &amp;__that) <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _M_p &lt;= __that._M_p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(UniquePtr <span class="type">const</span> &amp;__that) <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _M_p &gt; __that._M_p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(UniquePtr <span class="type">const</span> &amp;__that) <span class="type">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _M_p &gt;= __that._M_p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Deleter</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UniquePtr</span>&lt;_Tp[], _Deleter&gt; : UniquePtr&lt;_Tp, _Deleter&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> UniquePtr&lt;_Tp, _Deleter&gt;::UniquePtr;</span><br><span class="line"></span><br><span class="line">    std::<span class="type">add_lvalue_reference_t</span>&lt;_Tp&gt; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> __i) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get</span>()[__i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> ..._Args, std::<span class="type">enable_if_t</span>&lt;!std::is_unbounded_array_v&lt;_Tp&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">UniquePtr&lt;_Tp&gt; <span class="built_in">makeUnique</span>(_Args &amp;&amp;...__args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UniquePtr</span>&lt;_Tp&gt;(<span class="keyword">new</span> _Tp(std::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, std::<span class="type">enable_if_t</span>&lt;!std::is_unbounded_array_v&lt;_Tp&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">UniquePtr&lt;_Tp&gt; <span class="built_in">makeUniqueForOverwrite</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UniquePtr</span>&lt;_Tp&gt;(<span class="keyword">new</span> _Tp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, std::<span class="type">enable_if_t</span>&lt;std::is_unbounded_array_v&lt;_Tp&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">UniquePtr&lt;_Tp&gt; <span class="built_in">makeUnique</span>(std::<span class="type">size_t</span> __len) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UniquePtr</span>&lt;_Tp&gt;(<span class="keyword">new</span> std::<span class="type">remove_extent_t</span>&lt;_Tp&gt;[__len]());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, std::<span class="type">enable_if_t</span>&lt;std::is_unbounded_array_v&lt;_Tp&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">UniquePtr&lt;_Tp&gt; <span class="built_in">makeUniqueForOverwrite</span>(std::<span class="type">size_t</span> __len) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UniquePtr</span>&lt;_Tp&gt;(<span class="keyword">new</span> std::<span class="type">remove_extent_t</span>&lt;_Tp&gt;[__len]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>触发点记忆：</p>
<ul>
<li><code>T b(a);</code> &#x2F; <code>T b = a;</code> → 拷贝构造</li>
<li><code>b = a;</code> → 拷贝赋值</li>
<li><code>T b(std::move(a));</code> → 移动构造（若存在）</li>
<li><code>b = std::move(a);</code> → 移动赋值（若存在）</li>
</ul>
<hr>
<h2 id="8-结合你的-UniquePtr：哪些函数为什么这样写"><a href="#8-结合你的-UniquePtr：哪些函数为什么这样写" class="headerlink" title="8. 结合你的 UniquePtr：哪些函数为什么这样写"></a>8. 结合你的 <code>UniquePtr</code>：哪些函数为什么这样写</h2><h3 id="8-1-设计语义：唯一所有权"><a href="#8-1-设计语义：唯一所有权" class="headerlink" title="8.1 设计语义：唯一所有权"></a>8.1 设计语义：唯一所有权</h3><ul>
<li>拷贝构造&#x2F;拷贝赋值：必须禁用（否则 double delete 风险）</li>
<li>移动构造&#x2F;移动赋值：允许，以“转移所有权”方式工作</li>
<li>析构：负责释放所拥有资源</li>
</ul>
<h3 id="8-2-移动赋值中-this-that"><a href="#8-2-移动赋值中-this-that" class="headerlink" title="8.2 移动赋值中 this != &amp;that"></a>8.2 移动赋值中 <code>this != &amp;that</code></h3><p>这不是“通过 &amp;this 移动”，而是：</p>
<ul>
<li><code>this</code>：当前对象指针</li>
<li><code>&amp;that</code>：对方对象地址</li>
<li>防止自移动导致逻辑异常（虽少见，但工程上是标准保护）</li>
</ul>
<h3 id="8-3-std-exchange-的意义"><a href="#8-3-std-exchange-的意义" class="headerlink" title="8.3 std::exchange 的意义"></a>8.3 <code>std::exchange</code> 的意义</h3><p><code>_M_p = std::exchange(that._M_p, nullptr)</code> 一句完成：</p>
<ul>
<li>把 <code>that._M_p</code> 旧值转交给我</li>
<li>同时把 <code>that._M_p</code> 置空，保证 that 析构不会释放同一资源</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>现代C++实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>RAII</tag>
        <tag>智能指针</tag>
        <tag>移动语义</tag>
      </tags>
  </entry>
  <entry>
    <title>生命周期</title>
    <url>/2026/01/17/%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E8%B7%B5/%5B2%5D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>time：26_1_17</p>
<h2 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h2><p>1.{}范围内进行释放<br>2.如果没有保存；结束后释放</p>
<h2 id="左指右值"><a href="#左指右值" class="headerlink" title="左指右值"></a>左指右值</h2><p>&amp; 左指 ；结束后释放<br>&amp;&amp; 右指所有权，不会随意释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;utilty&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mystring</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)<span class="number">+1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Mystring*()&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动构造</span></span><br><span class="line">    Mystring &amp; operatir = (Mystring &amp;&amp; other)&#123;</span><br><span class="line">        <span class="keyword">if</span>(other.data != <span class="keyword">this</span>.data)&#123;</span><br><span class="line">            data = other.data;</span><br><span class="line">            other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>现代C++实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>RAII</tag>
        <tag>对象生命周期</tag>
        <tag>构造与析构</tag>
      </tags>
  </entry>
  <entry>
    <title>生产消费者模式</title>
    <url>/2026/01/19/%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E8%B7%B5/%5B3%5D%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="生产消费者模式"><a href="#生产消费者模式" class="headerlink" title="生产消费者模式"></a>生产消费者模式</h1><p>time：26_1_19<br>多线程开发，生成消费者模式，关键就在与三个参数。互斥。通知 和队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全队列模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SafeQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SafeQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">SafeQueue</span>(<span class="type">const</span> SafeQueue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SafeQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SafeQueue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(item));</span><br><span class="line">        m_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作，阻塞等待直到队列非空</span></span><br><span class="line">    <span class="function">T <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        T item = std::<span class="built_in">move</span>(m_queue.<span class="built_in">front</span>());</span><br><span class="line">        m_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试出队，不阻塞</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_dequeue</span><span class="params">(T&amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(m_queue.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        item = std::<span class="built_in">move</span>(m_queue.<span class="built_in">front</span>());</span><br><span class="line">        m_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m_mutex; <span class="comment">// 互斥</span></span><br><span class="line">    std::queue&lt;T&gt; m_queue; <span class="comment">// 队列</span></span><br><span class="line">    std::condition_variable m_cond;<span class="comment">// 通知</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试队列和线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SafeQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer</span><span class="params">([&amp;tasks]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            tasks.enqueue([i]() &#123; std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; executed&quot;</span>; &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">consumer</span><span class="params">([&amp;tasks]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">auto</span> task = tasks.dequeue();</span></span></span><br><span class="line"><span class="params"><span class="function">            task();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>现代C++实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
        <tag>生产者消费者</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂设计模式</title>
    <url>/2026/01/20/%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E8%B7%B5/%5B4%5D.%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h1><p>time：2026_1_20</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>virtual<br>即使通过基类的指针或引用调用该函数，实际调用的函数是派生类中重写的版本<br>override<br>如果派生类在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译<br>virtual 定义了父类中的子类需要重载的函数，override 则是确保子类在继承父类的时候必须进行重载，以防后续错误</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pet</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cat</span>::pet&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;miao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dog</span>::pet&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;wano&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feed</span><span class="params">(Pet *pet)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;喂食&quot;</span>);</span><br><span class="line">    pet-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;喂食完毕&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pet *cat = <span class="keyword">new</span> <span class="built_in">cat</span>();</span><br><span class="line">    pet *dog = <span class="keyword">new</span> <span class="built_in">dog</span>();</span><br><span class="line">    <span class="built_in">freed</span>(cat);</span><br><span class="line">    <span class="built_in">freed</span>(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sturct <span class="title">Reduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">init</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">add_our</span> :: <span class="built_in">Reduce</span>()&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">chen_our</span> :: <span class="built_in">Reduce</span>()&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reduce</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; v,Reduce &amp; reducer)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x =reducer-&gt;<span class="built_in">int</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++ )&#123;</span><br><span class="line">        x = reducer-&gt;<span class="built_in">add</span>(x, v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式：共享多个对象之间相同的部分，节省内存开销<br>共享同智能指标share_ptr实现多个对象指向同个资源在减少资源开销的同时，也通过rall特性完成智能内存管理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sprite</span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; texture;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(glm::vec3 posoition)</span></span>&#123;</span><br><span class="line">        <span class="built_in">glDrawPixels</span>(posoition, texture);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bullet</span>&#123;</span><br><span class="line">    glm::vec3 posoition;</span><br><span class="line">    glm::vec3 velocity;</span><br><span class="line">    shared_ptr&lt;Sprite&gt; sprite;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sprite-&gt;<span class="built_in">draw</span>(position, velocity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2>]]></content>
      <categories>
        <category>学习</category>
        <category>现代C++实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的注意事项</title>
    <url>/2026/01/22/%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E8%B7%B5/%5B6%5D%E6%A0%88%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="栈的注意事项"><a href="#栈的注意事项" class="headerlink" title="栈的注意事项"></a>栈的注意事项</h1><p>time：2026_1_22</p>
<h2 id="引用修改"><a href="#引用修改" class="headerlink" title="引用修改"></a>引用修改</h2><p>char * 指针能使用任意类型，可以对任意类型的进行字节修改</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>元素在栈上的空间可能不连续，这是由于编译器在编译过程中会产生的优化，可能会出现原本连续的元素，但是其中的元素没有使用，编译优化就不进行字节分配，然后通过其它指针进行访问就会出发未定义行为。<br>为了防止为定义行为最好还是用start进行封装</p>
<p>malloc 分配的时候默认会安装最大字节进行分配 16字节</p>
<p>new 智能分配字节</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>现代C++实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏设计者模式(未待完续)</title>
    <url>/2026/01/21/%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E8%B7%B5/%5B5%5D%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E8%80%85%E6%A8%A1%E5%BC%8F(%E6%9C%AA%E5%BE%85%E5%AE%8C%E7%BB%AD)/</url>
    <content><![CDATA[<h1 id="游戏设计者模式"><a href="#游戏设计者模式" class="headerlink" title="游戏设计者模式"></a>游戏设计者模式</h1><p>time：2026_1_21</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>通常用于游戏中的全局管理类，保证整个程序（进程）中只有一个实例对象存在。只有第一次调用会进行初始化，后面调用保持原始状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Game *<span class="title">getgame</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(game == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        game = <span class="built_in">new</span>(Game);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> game;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Game *game</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>把共同的部分集中到一个基类，把不同的细节部分留给子类实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Character</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">move</span>();</span><br><span class="line">        <span class="built_in">move</span>();</span><br><span class="line">        <span class="built_in">move</span>();</span><br><span class="line">        <span class="built_in">drow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Game</span>&#123;</span><br><span class="line">    vector&lt;character *&gt; chars;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp; c : chars)&#123;</span><br><span class="line">            c-&gt;<span class="built_in">updata</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>为了解决枚举问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Monster;</span><br><span class="line"></span><br><span class="line">struct State &#123;</span><br><span class="line">    virtual void update(Monster *monster) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Idle : State &#123;</span><br><span class="line">    void update(Monster *monster) override &#123;</span><br><span class="line">        if (monster-&gt;seesPlayer()) &#123;</span><br><span class="line">            monster-&gt;setState(new Chase());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Chase : State &#123;</span><br><span class="line">    void update(Monster *monster) override &#123;</span><br><span class="line">        if (monster-&gt;canAttack()) &#123;</span><br><span class="line">            monster-&gt;setState(new Attack());</span><br><span class="line">        &#125; else if (!monster-&gt;seesPlayer()) &#123;</span><br><span class="line">            monster-&gt;setState(new Idle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Attack : State &#123;</span><br><span class="line">    void update(Monster *monster) override &#123;</span><br><span class="line">        if (!monster-&gt;seesPlayer()) &#123;</span><br><span class="line">            monster-&gt;setState(new Idle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Monster &#123;</span><br><span class="line">    State *state = new Idle();</span><br><span class="line"></span><br><span class="line">    void update() &#123;</span><br><span class="line">        state-&gt;update(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setState(State *newState) &#123;</span><br><span class="line">        delete state;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>主要解决问题时深拷贝的问题，因为在虚函数会导致的拷贝构造函数会出现拷贝不完全的情况，所以要采用原型模型进行完整数据类型拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视线深拷贝</span></span><br><span class="line">Ball *ball = <span class="keyword">new</span> <span class="built_in">RedBall</span>();</span><br><span class="line">Ball *newball = <span class="keyword">new</span> <span class="built_in">BedBall</span>(*<span class="built_in">dynamic_cast</span>&lt;RedBall *&gt;(ball));</span><br></pre></td></tr></table></figure>
<p>原型模式将对象的拷贝方法作为虚函数，返回一个虚接口的指针，避免了直接拷贝类型。但虚函数内部会调用子类真正的构造函数，实现深拷贝。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Ball</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">thread_ptr</span><span class="params">(Ball)</span> *<span class="title">close</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//加入thread_ptr 实现内存智能管理</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RedBall</span> :Ball&#123;</span><br><span class="line">    <span class="built_in">thread_ptr</span>(Ball) *<span class="built_in">close</span>() <span class="keyword">override</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RedBall</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x ;<span class="comment">// 如果有成员变量，也会一并被拷贝到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ball *ball = <span class="keyword">new</span> <span class="built_in">RedBall</span>();</span><br><span class="line">Ball *ball_2 = ball-&gt;<span class="built_in">close</span>(); <span class="comment">//视线深拷贝,</span></span><br></pre></td></tr></table></figure>
<p>CRTP 模式自动实现 clone CRTP能将子类加入模版中已放置重复定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Ball</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> unique_ptr&lt;Ball&gt; <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BallImpl</span> : Ball &#123;  <span class="comment">// 自动实现 clone 的辅助工具类</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Ball&gt; <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        Derived *that = <span class="built_in">static_cast</span>&lt;Derived *&gt;(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_unique</span>&lt;Derived&gt;(*that);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RedBall</span> : BallImpl&lt;RedBall&gt; &#123;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;Ball&gt; clone() override &#123;       // BallImpl 自动实现的 clone 等价于</span></span><br><span class="line">    <span class="comment">//     return make_unique&lt;RedBall&gt;(*this);  // 调用 RedBall 的拷贝构造函数</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BlueBall</span> : BallImpl&lt;BlueBall&gt; &#123;</span><br><span class="line">    <span class="comment">// unique_ptr&lt;Ball&gt; clone() override &#123;       // BallImpl 自动实现的 clone 等价于</span></span><br><span class="line">    <span class="comment">//     return make_unique&lt;BlueBall&gt;(*this);  // 调用 BlueBall 的拷贝构造函数</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Ball *ball = <span class="keyword">new</span> <span class="built_in">RedBall</span>();</span><br><span class="line">Ball *ball_2 = ball-&gt;<span class="built_in">close</span>(); <span class="comment">//视线深拷贝,</span></span><br></pre></td></tr></table></figure>

<h2 id="组件模式"><a href="#组件模式" class="headerlink" title="组件模式"></a>组件模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">connect</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updata</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>


<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2>]]></content>
      <categories>
        <category>学习</category>
        <category>现代C++实践</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>allocator动态内存分配</title>
    <url>/2026/01/09/%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3C++%E5%AE%9E%E8%B7%B5/allocator%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h1 id="allocator-自定义动态分配"><a href="#allocator-自定义动态分配" class="headerlink" title="allocator 自定义动态分配"></a>allocator 自定义动态分配</h1><p>time:2026_1_9<br>std::allocator 是 C++ 标准库中的一个模板类，主要用于内存的分配和释放。它是 STL 容器（如 std::vector、std::list 等）的默认内存分配器，提供了灵活的内存管理功能。通过 std::allocator，用户可以自定义内存分配策略，从而更高效地管理程序的内存。</p>
<h2 id="自定义分配器"><a href="#自定义分配器" class="headerlink" title="自定义分配器"></a>自定义分配器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myallocator</span>:<span class="keyword">public</span> std::allocator&lt;T&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> std::allocator&lt;T&gt;::allocator;</span><br><span class="line">    <span class="function">T *<span class="title">allocator</span><span class="params">(std::<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::allocator&lt;t&gt;::<span class="built_in">allcator</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocator</span><span class="params">(T *p, std::<span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">        std::allocator&lt;T&gt;::<span class="built_in">deallocator</span>(p,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>现代C++实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
        <tag>allocator</tag>
      </tags>
  </entry>
  <entry>
    <title>Masked Autoencoders Are Scalable Vision Learners</title>
    <url>/2025/12/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%89%A9%E6%95%A3/%5B%E4%BD%95%E6%81%BA%E6%98%8E%5DMasked%20Autoencoders%20Are%20Scalable%20Vision%20Learners/</url>
    <content><![CDATA[<h1 id="Masked-Autoencoders-Are-Scalable-Vision-Learners"><a href="#Masked-Autoencoders-Are-Scalable-Vision-Learners" class="headerlink" title="Masked Autoencoders Are Scalable Vision Learners"></a>Masked Autoencoders Are Scalable Vision Learners</h1><p>论文地址：<a href="https://arxiv.org/pdf/2111.06377%E3%80%82">https://arxiv.org/pdf/2111.06377。</a><br>作者：何凯明<br>机构: Facebook</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>带掩码的自编码器是一个可拓展的视觉学习器<br>MAE基于两个核心设计，可以高效的训练大模型：<br>1、非对称的encoder-decoder架构编码器只作用在可见的patch中，对于丢掉的patch，编码器不会对它进行编码，这样能够节省一定的计算时间。解码器是一个比较轻量的解码器，拿到编码器的输出之后，重构被遮挡住的块。<br>2、使用较高的mask比例将mask比例设置为75%，迫使模型得到一个较好的自监督训练效果。如果只是遮住几块的话，只需要进行插值就可以出来了，模型可能学不到特别的东西。编码器只编码1&#x2F;4大小的图片，可以降低计算量，训练加速3倍或者以上模型结构。最终作者只使用一个最简单的ViT-Huge模型（模型结构来自ViT这篇文章），在ImageNet-1K（100万张图片）上预训练，准确率能达到87.8%；这个模型主要是用来做迁移学习，它证明了在迁移学习的其他任务上表现也非常好注：在ViT这篇文章的最后一段有提到过怎样做自监督学习，作者说效果并不是很好，结论是：用有标号的模型和大的训练集可以得到很好的效果。本文亮点是，只使用小的数据集（ImageNet-1k，100万张图片），而且是通过自监督，就能够做到跟之前可能效果一样好的模型了。</p>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="/img/notes/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%89%A9%E6%95%A3/%E5%9B%BE%E5%BA%93/MAE/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt="网络图"></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>扩散</category>
      </categories>
      <tags>
        <tag>MAE</tag>
        <tag>自监督学习</tag>
        <tag>Vision Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>让扩散模型回归“去噪”本质</title>
    <url>/2025/11/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%89%A9%E6%95%A3/%E4%BD%95%E5%87%AF%E6%98%8E%E8%AE%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E5%9B%9E%E5%BD%92%E2%80%9C%E5%8E%BB%E5%99%AA%E2%80%9D%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<h1 id="让扩散模型回归“去噪”本质"><a href="#让扩散模型回归“去噪”本质" class="headerlink" title="让扩散模型回归“去噪”本质"></a>让扩散模型回归“去噪”本质</h1><p>论文标题: Back to Basics: Let Denoising Generative Models Denoise<br>作者: Tianhong Li(黎天鸿), Kaiming He(何恺明)<br>机构: 麻省理工学院 (MIT)<br>论文地址: <a href="https://arxiv.org/abs/2511.13720">https://arxiv.org/abs/2511.13720</a><br>代码仓库: <a href="https://github.com/LTH14/JiT">https://github.com/LTH14/JiT</a><br>总结：本文指出了一个反常识问题，就是传统的去噪模型每步预测的唯噪声，而噪声在高维度中的分布是很难观察的，但是如果将预测噪声改为预测真实纯洁的图像就能改变这一问题。</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>扩散</category>
      </categories>
      <tags>
        <tag>扩散模型</tag>
        <tag>生成模型</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>盲超分</title>
    <url>/2025/11/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%B6%85%E5%88%86/%E7%9B%B2%E8%B6%85%E5%88%86/</url>
    <content><![CDATA[<h1 id="盲超分"><a href="#盲超分" class="headerlink" title="盲超分"></a>盲超分</h1><p>退化核？<br>综述：“看清”世界——从盲超分到真实超分 <a href="https://zhuanlan.zhihu.com/p/657729852">https://zhuanlan.zhihu.com/p/657729852</a></p>
<p>自监督：<a href="https://ieeexplore.ieee.org/document/10868396">https://ieeexplore.ieee.org/document/10868396</a><br>自监督：单一遥感高光谱图像的盲超分辨率<a href="https://github.com/zhiyuan0112/TSBSR">https://github.com/zhiyuan0112/TSBSR</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>超分</category>
      </categories>
      <tags>
        <tag>论文笔记</tag>
        <tag>超分辨率</tag>
        <tag>盲超分</tag>
      </tags>
  </entry>
  <entry>
    <title>禅与摩托车维修艺术</title>
    <url>/2025/12/09/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E8%AF%BB%E4%B9%A6%E6%9C%89%E6%84%9F/%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E8%BD%A6%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="良质"><a href="#良质" class="headerlink" title="良质"></a>良质</h1>]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>读书有感</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>哲学</tag>
        <tag>禅与摩托车维修艺术</tag>
      </tags>
  </entry>
  <entry>
    <title>黄山</title>
    <url>/2025/11/16/%E7%94%9F%E6%B4%BB/%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5/%E9%BB%84%E5%B1%B1/</url>
    <content><![CDATA[<h1 id="黄山"><a href="#黄山" class="headerlink" title="黄山"></a>黄山</h1><p><a href="https://www.nipic.com/show/50091343.html?utm_source=chatgpt.com"><img src="https://tse4.mm.bing.net/th/id/OIP.a92obHwocDrNicbuQrWrswHaJ1?cb=ucfimg2&pid=Api&ucfimg=1" alt="AI创作图黄山 奇松 山谷 云海 松树 绿色 自然 风景 旅行 摄影 中国 安徽省 地理 生态 宁静 壮丽nipic.com-昵图网"></a></p>
<h2 id="一、整体思路（预算版）"><a href="#一、整体思路（预算版）" class="headerlink" title="一、整体思路（预算版）"></a>一、整体思路（预算版）</h2><ul>
<li><p><strong>出行方式</strong>：广州 → 黄山北 高铁往返，二等座一般单程 520–600 元左右，往返约 1100–1200 元。(<a href="https://trains.ctrip.com/TrainBooking/guangzhounan-huangshan/gaotie/?utm_source=chatgpt.com" title="广州南到黄山高铁查询">携程火车票</a>)</p>
</li>
<li><p><strong>住宿策略</strong>：</p>
<ul>
<li>不住山上，<strong>两晚都住山下（汤口或者屯溪）</strong>，选 100–150&#x2F;晚的经济型酒店&#x2F;客栈。</li>
</ul>
</li>
<li><p><strong>景点选择</strong>：</p>
<ul>
<li>D1–D2：黄山一日半：走索道+步行的轻量版线路</li>
<li>D3：宏村半日 + 黄山市区随便逛，视预算可选</li>
</ul>
</li>
<li><p><strong>控制花费的小技巧</strong>：</p>
<ul>
<li>索道只坐一段（上山坐，视体力下山走部分路）。</li>
<li>山上的水&#x2F;零食尽量自带一些。</li>
<li>宏村可以跟当地一日游&#x2F;拼车，省心也省一点车费。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二、详细行程规划"><a href="#二、详细行程规划" class="headerlink" title="二、详细行程规划"></a>二、详细行程规划</h2><h3 id="▶-D1：广州-→-黄山北-→-汤口-屯溪（轻松抵达日）"><a href="#▶-D1：广州-→-黄山北-→-汤口-屯溪（轻松抵达日）" class="headerlink" title="▶ D1：广州 → 黄山北 → 汤口&#x2F;屯溪（轻松抵达日）"></a>▶ D1：广州 → 黄山北 → 汤口&#x2F;屯溪（轻松抵达日）</h3><p><strong>上午 &#x2F; 中午</strong></p>
<ul>
<li><p>从 <strong>广州南&#x2F;广州东&#x2F;广州新塘 → 黄山北</strong> 坐高铁，尽量选中午前出发、下午两三点到黄山北的车次（车程约 5 小时）。(<a href="https://tw.trip.com/trains/china/route/guangzhou-to-huangshan/?utm_source=chatgpt.com" title="從廣州到黃山的高鐵預訂、票價及時刻表">Trip.com</a>)</p>
</li>
<li><p>黄山北出站后：</p>
<ul>
<li>若第二天一早上黄山：建议直接去 <strong>汤口镇（黄山南大门）</strong>，大巴或拼车约 1–1.5 小时。</li>
<li>若想市区逛一逛：可以先住 <strong>屯溪老街附近</strong>，晚上吃吃逛逛。</li>
</ul>
</li>
</ul>
<p><strong>下午 &#x2F; 晚上</strong></p>
<ul>
<li>办理入住（控制在 <strong>100–150 元&#x2F;晚</strong> 的快捷酒店&#x2F;客栈）。</li>
<li>在屯溪的话：逛 <strong>屯溪老街</strong>，吃一顿徽菜（毛豆腐、臭鳜鱼、刀板香等）。</li>
<li>在汤口的话：熟悉第二天上山的大巴、售票处位置，早点休息。</li>
</ul>
<blockquote>
<p>建议：预算紧 &amp; 主要目标是黄山 → <strong>D1 晚上住汤口</strong> 会更高效，第二天可以早早上山。</p>
</blockquote>
<hr>
<h3 id="▶-D2：黄山一日游（索道-精华步行，不住山上）"><a href="#▶-D2：黄山一日游（索道-精华步行，不住山上）" class="headerlink" title="▶ D2：黄山一日游（索道 + 精华步行，不住山上）"></a>▶ D2：黄山一日游（索道 + 精华步行，不住山上）</h3><blockquote>
<p>预算版选择：<strong>黄山一日“精华速刷版”</strong>，不上主峰也能感受到黄山特色。</p>
</blockquote>
<p><strong>早上</strong></p>
<ol>
<li><p>早起从酒店 → 汤口新国线换乘中心</p>
</li>
<li><p>买票：</p>
<ul>
<li>景区门票：平旺季 <strong>190 元&#x2F;人</strong>(<a href="https://hf.bendibao.com/tour/2023331/91141.shtm?utm_source=chatgpt.com" title="黄山门票多少钱2025？附索道价格">hf.bendibao.com</a>)</li>
<li>景区大巴：单程 19 元，上下山合计约 38 元。(<a href="https://wap.huangshan.com.cn/hsdetail/ticket/park2017122114525726?addressLabel=04&utm_source=chatgpt.com" title="黄山风景区-门票索道详情">wap.huangshan.com.cn</a>)</li>
</ul>
</li>
<li><p>坐大巴到 <strong>云谷寺（后山口）</strong> → 再坐 <strong>云谷索道上山</strong>，单程 80 元左右（平旺季）。(<a href="https://hf.bendibao.com/tour/2023331/91141.shtm?utm_source=chatgpt.com" title="黄山门票多少钱2025？附索道价格">hf.bendibao.com</a>)</p>
</li>
</ol>
<p><strong>上山后推荐线路（强度中等）：</strong></p>
<ul>
<li>索道上站（白鹅岭） → 始信峰（看奇松、怪石）</li>
<li>北海景区：清凉台、猴子观海 等观景点</li>
<li>喜欢走一点路的：可以往 西海入口 方向走一段，再折返，不进大峡谷深处（省体力）。</li>
<li>中午在北海&#x2F;光明顶附近简单吃点自带干粮或景区快餐。</li>
</ul>
<p><strong>下午下山</strong></p>
<ul>
<li><p>体力不错：</p>
<ul>
<li>从北海 → 白鹅岭 → 步行下到 <strong>云谷寺</strong>（路程较长但一路风景不错）。</li>
</ul>
</li>
<li><p>体力一般：</p>
<ul>
<li>返回云谷索道上站 → 再坐索道下山（再花 1×80 元）。</li>
</ul>
</li>
</ul>
<p>然后：云谷寺 → 大巴 → 汤口 → 回酒店休息。</p>
<blockquote>
<p>不上天都峰&#x2F;莲花峰，可以大幅度降低体力和时间消耗，一天玩得比较从容。</p>
</blockquote>
<hr>
<h3 id="▶-D3：宏村半日游-回广州"><a href="#▶-D3：宏村半日游-回广州" class="headerlink" title="▶ D3：宏村半日游 + 回广州"></a>▶ D3：宏村半日游 + 回广州</h3><p><strong>早上：汤口&#x2F;屯溪 → 宏村</strong></p>
<ul>
<li>从汤口&#x2F;黄山市区报一个去 <strong>宏村的拼车&#x2F;一日游</strong>，或者去汽车站坐车，车程约 1–1.5 小时。</li>
<li>宏村门票：成人约 <strong>90–100 元左右</strong>。(<a href="https://touch.piao.qunar.com/touch/detail.htm?cat=from_area=ts_sku&from_index=4&from_value=%25E5%2590%2588%25E8%2582%25A5%25E5%25BF%2585%25E6%25B8%25B8&dist_city=%25E6%25B7%25AE%25E5%258C%2597&id=11072&utm_source=chatgpt.com" title="宏村景区门票 - 景点门票预订- 去哪儿网">去哪儿网</a>)</li>
</ul>
<p><strong>宏村游玩重点：</strong></p>
<ul>
<li>南湖、月沼：徽派建筑 + 水面倒影，拍照很好看。</li>
<li>巷子里慢慢走走，找几家咖啡&#x2F;小吃店坐坐，体验古村氛围。</li>
</ul>
<p><strong>下午</strong></p>
<ul>
<li>午后从宏村 → 返回黄山北 &#x2F; 屯溪。</li>
<li>预留足够时间，傍晚或晚上坐高铁 <strong>黄山北 → 广州</strong>。</li>
</ul>
<hr>
<h2 id="三、人均费用粗算（按“2000-左右”来配）"><a href="#三、人均费用粗算（按“2000-左右”来配）" class="headerlink" title="三、人均费用粗算（按“2000 左右”来配）"></a>三、人均费用粗算（按“2000 左右”来配）</h2><blockquote>
<p>下表是<strong>大致估算</strong>，实际以你订到的车票&#x2F;酒店为准。</p>
</blockquote>
<h3 id="1-大头：往返高铁"><a href="#1-大头：往返高铁" class="headerlink" title="1. 大头：往返高铁"></a>1. 大头：往返高铁</h3><ul>
<li>广州 → 黄山北 二等座：约 520–600 元</li>
<li>黄山北 → 广州 二等座：约 520–600 元<br>👉 合计按 <strong>1100–1200 元</strong> 预估。(<a href="https://trains.ctrip.com/TrainBooking/guangzhounan-huangshan/gaotie/?utm_source=chatgpt.com" title="广州南到黄山高铁查询">携程火车票</a>)</li>
</ul>
<h3 id="2-景区门票-索道-大巴"><a href="#2-景区门票-索道-大巴" class="headerlink" title="2. 景区门票 + 索道 + 大巴"></a>2. 景区门票 + 索道 + 大巴</h3><ul>
<li><p>黄山门票：190</p>
</li>
<li><p>黄山景区大巴：38（往返）</p>
</li>
<li><p>索道：</p>
<ul>
<li>只坐上行一次：80</li>
<li>若上下都坐：160</li>
</ul>
</li>
<li><p>宏村门票：约 94（按网上成人价估算）(<a href="https://touch.piao.qunar.com/touch/detail.htm?cat=from_area=ts_sku&from_index=4&from_value=%25E5%2590%2588%25E8%2582%25A5%25E5%25BF%2585%25E6%25B8%25B8&dist_city=%25E6%25B7%25AE%25E5%258C%2597&id=11072&utm_source=chatgpt.com" title="宏村景区门票 - 景点门票预订- 去哪儿网">去哪儿网</a>)</p>
</li>
</ul>
<p><strong>控制版（只坐单程索道）合计：</strong><br><code>190 + 38 + 80 + 94 ≈ 402 元</code></p>
<p>如果你觉得体力一般，上下都坐索道：<br><code>190 + 38 + 160 + 94 ≈ 482 元</code></p>
<h3 id="3-住宿"><a href="#3-住宿" class="headerlink" title="3. 住宿"></a>3. 住宿</h3><ul>
<li>D1：汤口&#x2F;屯溪经济型酒店 100–150</li>
<li>D2：同上，再 100–150<br>👉 住宿预估：<strong>200–300 元</strong></li>
</ul>
<h3 id="4-吃饭-当地交通"><a href="#4-吃饭-当地交通" class="headerlink" title="4. 吃饭 + 当地交通"></a>4. 吃饭 + 当地交通</h3><ul>
<li>吃饭按 <strong>80–100 元&#x2F;天</strong> 算，3 天 ≈ 240–300 元</li>
<li>市内&#x2F;镇内小交通、拼车到宏村等：预留 <strong>100–150 元</strong>。</li>
</ul>
<hr>
<h3 id="5-总体汇总（偏省钱方案）"><a href="#5-总体汇总（偏省钱方案）" class="headerlink" title="5. 总体汇总（偏省钱方案）"></a>5. 总体汇总（偏省钱方案）</h3><p>按较省的方式估算（高铁 1100、索道只坐一次、酒店便宜点）：</p>
<ul>
<li>高铁：1100</li>
<li>黄山 + 宏村门票&#x2F;车&#x2F;索道：约 400</li>
<li>住宿：约 250</li>
<li>吃饭 + 小交通：约 350</li>
</ul>
<p><strong>合计 ≈ 2100 元左右</strong></p>
<blockquote>
<p>也就是说：<strong>“两千左右”是可以做到的，但会略微紧张</strong>，主要看你高铁能不能抢到稍便宜的车次、酒店选多便宜的、索道坐几次。<br>如果你想更轻松一点（多坐索道、吃好一点），建议心里预留到 <strong>2200–2300</strong> 更舒服。</p>
</blockquote>
<hr>
<h2 id="四、给你一个能直接照抄的简短行程版"><a href="#四、给你一个能直接照抄的简短行程版" class="headerlink" title="四、给你一个能直接照抄的简短行程版"></a>四、给你一个能直接照抄的简短行程版</h2><ul>
<li><strong>D1</strong>：广州 → 黄山北（高铁）→ 汤口，入住；晚上简单逛逛、准备上山物资。</li>
<li><strong>D2</strong>：汤口 → 黄山（云谷索道上 → 北海 → 始信峰 → 光明顶附近 → 视体力部分步行下山&#x2F;坐索道下），晚上回汤口 &#x2F; 屯溪休息。</li>
<li><strong>D3</strong>：早上去宏村（南湖、月沼拍照闲逛），下午返回黄山北，傍晚&#x2F;晚上高铁回广州。</li>
</ul>
<p>如果你愿意告诉我<strong>大概出行月份 + 更偏“省钱”还是“轻松”</strong>，我可以帮你把上面每一天细到：大概几点出门、建议坐的车次时段、黄山具体走哪条步行路线，给你一个“可直接发给同伴&#x2F;直接订票用”的终版行程单。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>旅游攻略</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>黄山</tag>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透</title>
    <url>/2026/02/05/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="内网穿透方案-ZeroTier"><a href="#内网穿透方案-ZeroTier" class="headerlink" title="内网穿透方案_ZeroTier"></a>内网穿透方案_ZeroTier</h1><h2 id="Liunx-配置"><a href="#Liunx-配置" class="headerlink" title="Liunx 配置"></a>Liunx 配置</h2><ol>
<li>安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://install.zerotier.com | <span class="built_in">sudo</span> bash</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动并设为开机自启</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now zerotier-one</span><br><span class="line"><span class="built_in">sudo</span> systemctl status zerotier-one --no-pager</span><br></pre></td></tr></table></figure>

<p>) 加入网络（Network ID）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> zerotier-cli <span class="built_in">join</span> &lt;NETWORK_ID&gt;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li><p>去 Central 授权</p>
</li>
<li><p>验证是否拿到 Managed IP</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> zerotier-cli status</span><br><span class="line"><span class="built_in">sudo</span> zerotier-cli listnetworks</span><br><span class="line">ip a | grep -n <span class="string">&quot;zt&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Windows（Win10-Win11）"><a href="#Windows（Win10-Win11）" class="headerlink" title="Windows（Win10&#x2F;Win11）"></a>Windows（Win10&#x2F;Win11）</h2><ol>
<li>安装</li>
</ol>
<ol>
<li>去 ZeroTier 官网下载 Windows Installer（.msi &#x2F; .exe）</li>
<li>双击安装（默认一路 Next 即可）</li>
</ol>
<ol start="2">
<li>启动方式</li>
</ol>
<ul>
<li>安装后通常会自动启动服务，并在右下角托盘出现 <strong>ZeroTier</strong> 图标</li>
<li>若没看到托盘图标：开始菜单打开 <strong>ZeroTier One</strong>（会拉起托盘）</li>
<li>或检查服务：<code>Win + R</code> → <code>services.msc</code> → 找到 <strong>ZeroTier One</strong>（或类似名字）→ 启动</li>
</ul>
<ol start="3">
<li>加入网络（GUI）</li>
</ol>
<ol>
<li>右下角托盘 ZeroTier 图标右键</li>
<li><strong>Join New Network…</strong></li>
<li>粘贴 <code>&lt;NETWORK_ID&gt;</code> → Join</li>
</ol>
<h2 id="最小联通测试"><a href="#最小联通测试" class="headerlink" title="最小联通测试"></a>最小联通测试</h2><p>在任意一端用对方 Managed IP：</p>
<ul>
<li>测试连通：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping &lt;对方Managed_IP&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>SSH（Linux 目标）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh user@&lt;对方Managed_IP&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>RDP（Windows 目标，默认 3389）：<br><code>mstsc /v:&lt;对方Managed_IP&gt;</code></li>
</ul>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>构建系统</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
</search>
